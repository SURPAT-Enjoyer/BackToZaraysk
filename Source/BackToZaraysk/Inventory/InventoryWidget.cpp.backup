#include "InventoryWidget.h"
#include "InventoryItemData.h"
#include "EquippableItemData.h"
#include "EquipmentSlotType.h"
#include "BackToZaraysk/Characters/PlayerCharacter.h"
#include "BackToZaraysk/Inventory/InventoryItemWidget.h"
#include "Components/CanvasPanel.h"
#include "Components/CanvasPanelSlot.h"
#include "Components/Border.h"
#include "Components/TextBlock.h"
#include "Components/PanelWidget.h"
#include "Components/Image.h"
#include "InventoryGridWidget.h"
#include "Blueprint/WidgetTree.h"
#include "Slate/SlateBrushAsset.h"
#include "Styling/SlateColor.h"
#include "Engine/Texture2D.h"
#include "Components/Border.h"
#include "Blueprint/WidgetBlueprintLibrary.h"
#include "BackToZaraysk/Characters/BTZBaseCharacter.h"
#include "BackToZaraysk/Characters/PlayerCharacter.h"
#include "BackToZaraysk/Inventory/InventoryItemWidget.h"
#include "BackToZaraysk/Inventory/InventoryComponent.h"

void UInventoryWidget::NativeOnInitialized()
{
    Super::NativeOnInitialized();

    // –°—Ç—Ä–æ–∏–º UI –æ–¥–∏–Ω —Ä–∞–∑ –Ω–∞ —ç–∫–∑–µ–º–ø–ª—è—Ä (–≤–∞–∂–Ω–æ –¥–ª—è –Ω–æ–≤–æ–≥–æ PIE —Å–µ–∞–Ω—Å–∞)
    if (bUIBuilt) return;
    bUIBuilt = true;
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ –≤–∏–¥–∂–µ—Ç—ã
    VestItemWidgetRef = nullptr;

    // –ü–æ—Å—Ç—Ä–æ–∏–º –ø—Ä–æ—Å—Ç–æ–π UI –ø—Ä—è–º–æ –≤ C++, –¥–∞–∂–µ –µ—Å–ª–∏ –∫–ª–∞—Å—Å ‚Äî Blueprint —Å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –∫–æ—Ä–Ω–µ–≤—ã–º –≤–∏–¥–∂–µ—Ç–æ–º
    if (WidgetTree)
    {
        UPanelWidget* RootPanel = Cast<UPanelWidget>(WidgetTree->RootWidget);
        if (!RootPanel)
        {
            UCanvasPanel* NewRoot = WidgetTree->ConstructWidget<UCanvasPanel>(UCanvasPanel::StaticClass(), TEXT("RootCanvas"));
            WidgetTree->RootWidget = NewRoot;
            RootPanel = NewRoot;
        }

            if (UCanvasPanel* Canvas = Cast<UCanvasPanel>(RootPanel))
        {
            // –ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω–∞—è –ø–æ–¥–ª–æ–∂–∫–∞ —á–µ—Ä–µ–∑ UImage —Å —Ü–≤–µ—Ç–æ–º –∏ –∞–ª—å—Ñ–æ–π
            UImage* Backdrop = WidgetTree->ConstructWidget<UImage>(UImage::StaticClass(), TEXT("Backdrop"));
            Backdrop->SetColorAndOpacity(FLinearColor(0.f, 0.f, 0.f, 0.7f));
            if (UCanvasPanelSlot* BackdropSlot = Canvas->AddChildToCanvas(Backdrop))
            {
                BackdropSlot->SetAnchors(FAnchors(0.f, 0.f, 1.f, 1.f));
                BackdropSlot->SetOffsets(FMargin(0.f));
                BackdropSlot->SetZOrder(-100); // –§–æ–Ω –≤—Å–µ–≥–¥–∞ –Ω–∏–∂–µ –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
            }

            UTextBlock* Title = WidgetTree->ConstructWidget<UTextBlock>(UTextBlock::StaticClass(), TEXT("Title"));
            Title->SetText(FText::FromString(TEXT("–ò–ù–í–ï–ù–¢–ê–†–¨ (I ‚Äî –∑–∞–∫—Ä—ã—Ç—å)")));
            Title->SetJustification(ETextJustify::Center);
            Title->SetColorAndOpacity(FSlateColor(FLinearColor::White));
            Title->SetShadowColorAndOpacity(FLinearColor(0.f, 0.f, 0.f, 0.8f));
            Title->SetShadowOffset(FVector2D(1.f, 1.f));
            if (UCanvasPanelSlot* TitleSlot = Canvas->AddChildToCanvas(Title))
            {
                TitleSlot->SetAnchors(FAnchors(0.5f, 0.f, 0.5f, 0.f));
                TitleSlot->SetAlignment(FVector2D(0.5f, 0.f));
                TitleSlot->SetPosition(FVector2D(0.f, 40.f));
            }

            // –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å–ø—Ä–∞–≤–∞ –ø–æ–¥ 4 –≥—Ä–∏–¥-–æ–±–ª–∞—Å—Ç–∏ (—Ä–∞–∑–≥—Ä—É–∑–∫–∞/–ø–æ—è—Å/–∫–∞—Ä–º–∞–Ω—ã/—Ä—é–∫–∑–∞–∫)
            UCanvasPanel* RightPanel = WidgetTree->ConstructWidget<UCanvasPanel>(UCanvasPanel::StaticClass(), TEXT("RightPanel"));
            if (UCanvasPanelSlot* RightSlot = Canvas->AddChildToCanvas(RightPanel))
            {
                RightSlot->SetAnchors(FAnchors(1.f, 0.5f, 1.f, 0.5f));
                RightSlot->SetAlignment(FVector2D(1.f, 0.5f));
                RightSlot->SetPosition(FVector2D(-60.f, 0.f));
                RightSlot->SetSize(FVector2D(560.f, 760.f));
            }
            RightPanelRef = RightPanel;
            
            // –°–æ–∑–¥–∞–µ–º –ø–∞–Ω–µ–ª—å –¥–ª—è —Å–ª–æ—Ç–æ–≤ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏
            UCanvasPanel* EquipmentPanel = WidgetTree->ConstructWidget<UCanvasPanel>(UCanvasPanel::StaticClass(), TEXT("EquipmentPanel"));
            if (UCanvasPanelSlot* EquipmentSlot = Canvas->AddChildToCanvas(EquipmentPanel))
            {
                EquipmentSlot->SetAnchors(FAnchors(0.5f, 0.5f, 0.5f, 0.5f));
                EquipmentSlot->SetAlignment(FVector2D(0.5f, 0.5f));
                EquipmentSlot->SetPosition(FVector2D(0.f, 0.f));
                EquipmentSlot->SetSize(FVector2D(400.f, 600.f));
                EquipmentSlot->SetZOrder(10);
            }
            EquipmentPanelRef = EquipmentPanel;

            // –°–∏–ª—É—ç—Ç —á–µ–ª–æ–≤–µ–∫–∞ —Å–ª–µ–≤–∞. –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥ —Å–ª–æ—Ç—ã (–Ω–∏–∑–∫–∏–π Z), —á—Ç–æ–±—ã –Ω–µ –º–µ–Ω—è—Ç—å –∏—Ö –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
            {
                UImage* Silhouette = WidgetTree->ConstructWidget<UImage>(UImage::StaticClass(), TEXT("Silhouette"));
                // –ü–æ–ø—ã—Ç–∞—Ç—å—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–µ–∫—Å—Ç—É—Ä—É, –µ—Å–ª–∏ —Ö—É–¥–æ–∂–Ω–∏–∫ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–ª –µ—ë –∫–∞–∫ /Game/UI/T_Silhouette
                if (UTexture2D* SilTex = LoadObject<UTexture2D>(nullptr, TEXT("/Game/UI/T_Silhouette.T_Silhouette")))
                {
                    FSlateBrush Brush;
                    Brush.SetResourceObject(SilTex);
                    Brush.ImageSize = FVector2D(512.f, 1024.f);
                    Silhouette->SetBrush(Brush);
                    Silhouette->SetColorAndOpacity(FLinearColor(1.f, 1.f, 1.f, 0.25f));
                }
                else
                {
                    // –§–æ–ª–±—ç–∫: –±–µ–ª–∞—è –∫–≤–∞–¥—Ä–∞—Ç–Ω–∞—è —Ç–µ–∫—Å—Ç—É—Ä–∞ –∏–∑ –¥–≤–∏–∂–∫–∞, —Ç–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤ –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —á—ë—Ä–Ω—ã–π
                    if (UTexture2D* WhiteTex = LoadObject<UTexture2D>(nullptr, TEXT("/Engine/EngineResources/WhiteSquareTexture.WhiteSquareTexture")))
                    {
                        FSlateBrush Brush;
                        Brush.SetResourceObject(WhiteTex);
                        Brush.ImageSize = FVector2D(512.f, 1024.f);
                        Silhouette->SetBrush(Brush);
                        Silhouette->SetColorAndOpacity(FLinearColor(1.f, 1.f, 1.f, 0.35f));
                    }
                }
                if (UCanvasPanelSlot* SilSlot = Canvas->AddChildToCanvas(Silhouette))
                {
                    SilSlot->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                    SilSlot->SetAlignment(FVector2D(0.f, 0.f));
                    SilSlot->SetPosition(FVector2D(200.f, 120.f));
                    SilSlot->SetSize(FVector2D(240.f, 700.f));
                    SilSlot->SetZOrder(-1); // –í—ã—à–µ —Ñ–æ–Ω–∞, –Ω–∏–∂–µ —Å–ª–æ—Ç–æ–≤ –∏ –≥—Ä–∏–¥–æ–≤
                }
            }

            auto AddLabeledGrid = [&](const TCHAR* Label, float TopOffset, FVector2D GridSize, int32 GridWidth, int32 GridHeight, const TCHAR* SlotLabel = nullptr, bool bShowLabel = true)
            {
                // –°–ª–æ—Ç —Å–ª–µ–≤–∞ –æ—Ç –Ω–∞–¥–ø–∏—Å–∏
                if (SlotLabel)
                {
                    UBorder* Slot = WidgetTree->ConstructWidget<UBorder>(UBorder::StaticClass());
                    Slot->SetBrushColor(FLinearColor(1.f,1.f,1.f,0.05f));
                    if (UCanvasPanelSlot* SS = RightPanel->AddChildToCanvas(Slot))
                    {
                        SS->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                        SS->SetAlignment(FVector2D(0.f, 0.f));
                        SS->SetPosition(FVector2D(0.f, TopOffset));
                        SS->SetSize(FVector2D(60.f, 60.f));
                    }
                    
                    UTextBlock* SlotText = WidgetTree->ConstructWidget<UTextBlock>(UTextBlock::StaticClass());
                    SlotText->SetText(FText::FromString(SlotLabel));
                    SlotText->SetColorAndOpacity(FSlateColor(FLinearColor::White));
                    SlotText->SetJustification(ETextJustify::Center);
                    if (UCanvasPanelSlot* ST = RightPanel->AddChildToCanvas(SlotText))
                    {
                        ST->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                        ST->SetAlignment(FVector2D(0.f, 0.f));
                        ST->SetPosition(FVector2D(0.f, TopOffset + 60.f));
                        ST->SetSize(FVector2D(60.f, 20.f));
                    }
                }
                
                // –ù–∞–¥–ø–∏—Å—å - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ bShowLabel = true
                if (bShowLabel)
                {
                    UTextBlock* L = WidgetTree->ConstructWidget<UTextBlock>(UTextBlock::StaticClass());
                    L->SetText(FText::FromString(Label));
                    L->SetColorAndOpacity(FSlateColor(FLinearColor::White));
                    if (UCanvasPanelSlot* S = RightPanel->AddChildToCanvas(L))
                    {
                        S->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                        S->SetAlignment(FVector2D(0.f, 0.f));
                        S->SetPosition(FVector2D(SlotLabel ? 70.f : 0.f, TopOffset - 30.f));
                        S->SetSize(FVector2D(160.f, 24.f));
                    }
                }
                
                // –ì—Ä–∏–¥
                UInventoryGridWidget* GW = WidgetTree->ConstructWidget<UInventoryGridWidget>(UInventoryGridWidget::StaticClass());
                GW->GridWidth = GridWidth; 
                GW->GridHeight = GridHeight;
                if (UCanvasPanelSlot* GS = RightPanel->AddChildToCanvas(GW))
                {
                    GS->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                    GS->SetAlignment(FVector2D(0.f, 0.f));
                    const FVector2D Pos(SlotLabel ? 70.f : 0.f, TopOffset);
                    GS->SetPosition(Pos);
                    GS->SetSize(GridSize);
                    GS->SetAutoSize(false);
                    RegisterGrid(Label, Pos, GridSize, GridWidth, GridHeight);
                }
            };
            // –£–±–∏—Ä–∞–µ–º –≥—Ä–∏–¥ —Ä–∞–∑–≥—Ä—É–∑–∫–∏ –∏–∑ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–π —á–∞—Å—Ç–∏
            // AddLabeledGrid(TEXT("—Ä–∞–∑–≥—Ä—É–∑–∫–∞"), 0.f, FVector2D(480.f, 240.f), 8, 4, TEXT("—Ä–∞–∑–≥—Ä—É–∑–∫–∞"), false);
            AddLabeledGrid(TEXT("–ø–æ—è—Å"), 280.f, FVector2D(480.f, 120.f), 8, 2, TEXT("–ø–æ—è—Å"), false);
            AddLabeledGrid(TEXT("–∫–∞—Ä–º–∞–Ω—ã"), 430.f, FVector2D(240.f, 60.f), 4, 1, nullptr, true);
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–∏—Å—Ç–µ–º—É –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∑–∞–Ω—è—Ç—ã—Ö —è—á–µ–µ–∫
            InitializeOccupiedCells();
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∑–∞–Ω—è—Ç—ã–µ —è—á–µ–π–∫–∏ –¥–ª—è 6 –≥—Ä–∏–¥–æ–≤ –∂–∏–ª–µ—Ç–∞ (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è)
            VestOccupiedCells.SetNum(6); // 6 –≥—Ä–∏–¥–æ–≤
            // –ì—Ä–∏–¥—ã 1-2: 1x1
            for (int32 GridIndex = 0; GridIndex < 2; ++GridIndex)
            {
                VestOccupiedCells[GridIndex].SetNum(1); // 1 —Ä—è–¥
                VestOccupiedCells[GridIndex][0].SetNum(1); // 1 –∫–æ–ª–æ–Ω–∫–∞
                VestOccupiedCells[GridIndex][0][0] = false;
            }
            // –ì—Ä–∏–¥—ã 3-4: 1x2
            for (int32 GridIndex = 2; GridIndex < 4; ++GridIndex)
            {
                VestOccupiedCells[GridIndex].SetNum(2); // 2 —Ä—è–¥–∞
                for (int32 Row = 0; Row < 2; ++Row)
                {
                    VestOccupiedCells[GridIndex][Row].SetNum(1); // 1 –∫–æ–ª–æ–Ω–∫–∞
                    VestOccupiedCells[GridIndex][Row][0] = false;
                }
            }
            // –ì—Ä–∏–¥—ã 5-6: 1x1
            for (int32 GridIndex = 4; GridIndex < 6; ++GridIndex)
            {
                VestOccupiedCells[GridIndex].SetNum(1); // 1 —Ä—è–¥
                VestOccupiedCells[GridIndex][0].SetNum(1); // 1 –∫–æ–ª–æ–Ω–∫–∞
                VestOccupiedCells[GridIndex][0][0] = false;
            }
            
            // –ù–∞–π–¥—ë–º –∏–Ω–¥–µ–∫—Å —Ä—é–∫–∑–∞–∫–∞ –≤ –º–∞—Å—Å–∏–≤–∞—Ö –æ–±–ª–∞—Å—Ç–µ–π
            for (int32 i=0;i<GridAreas.Num();++i){ if (GridAreas[i].Name==TEXT("—Ä—é–∫–∑–∞–∫")) { false // Backpack grid removedIndex=i; break; }}

            // –õ–µ–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞ —Å–ª–æ—Ç–æ–≤ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏
            auto AddEquipSlot = [&](const TCHAR* Label, FVector2D Pos)
            {
                UTextBlock* L = WidgetTree->ConstructWidget<UTextBlock>(UTextBlock::StaticClass());
                L->SetText(FText::FromString(Label));
                L->SetColorAndOpacity(FSlateColor(FLinearColor::White));
                UBorder* Slot = WidgetTree->ConstructWidget<UBorder>(UBorder::StaticClass());
                Slot->SetBrushColor(FLinearColor(1.f,1.f,1.f,0.05f));
                if (UCanvasPanelSlot* LS = Canvas->AddChildToCanvas(L))
                {
                    LS->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                    LS->SetAlignment(FVector2D(0.f, 0.f));
                    LS->SetPosition(Pos);
                    LS->SetSize(FVector2D(120.f, 20.f));
                }
                if (UCanvasPanelSlot* SS = Canvas->AddChildToCanvas(Slot))
                {
                    SS->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                    SS->SetAlignment(FVector2D(0.f, 0.f));
                    SS->SetPosition(Pos + FVector2D(0.f, 20.f));
                    SS->SetSize(FVector2D(120.f, 80.f));
                }
            };
            // –ë–∞–∑–æ–≤—ã–µ —Å–ª–æ—Ç—ã –≤ –ª–µ–≤–æ–π –∫–æ–ª–æ–Ω–∫–µ
            float y=40.f;
            // –°–Ω–∞—á–∞–ª–∞ –ª–∏—Ü–æ, –∑–∞—Ç–µ–º –≥–ª–∞–∑–∞ –Ω–∏–∂–µ –Ω–µ–≥–æ
            AddEquipSlot(TEXT("–ª–∏—Ü–æ"), FVector2D(60.f,y)); y+=110.f;
            AddEquipSlot(TEXT("–≥–ª–∞–∑–∞"), FVector2D(60.f,y)); y+=110.f;
            
            // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–æ —Å–∏–ª—É—ç—Ç—É
            const float SilLeft = 200.f;
            const float SilTop = 120.f;
            const float SilWidth = 240.f;
            const float SilHeight = 700.f;
            const float SilCenterX = SilLeft + SilWidth * 0.5f; // 320
            const float SlotHalfWidth = 60.f; // —à–∏—Ä–∏–Ω–∞ 120
            const float LabelHeight = 20.f;
            const float BoxHeight = 80.f;
            const float Step = 120.f; // —Ä–∞–≤–Ω—ã–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏

            // –ì–æ–ª–æ–≤–∞: –Ω–∞ —É—Ä–æ–≤–Ω–µ "–ª–∏—Ü–æ", –ø–æ —Ü–µ–Ω—Ç—Ä—É —Å–∏–ª—É—ç—Ç–∞ (—Å–ø—Ä–∞–≤–∞ –æ—Ç "–ª–∏—Ü–æ")
            const float HeadY = 150.f;
            AddEquipSlot(TEXT("–≥–æ–ª–æ–≤–∞"), FVector2D(SilCenterX - SlotHalfWidth, HeadY)); y+=110.f;

            // –û–±—É–≤—å –æ—Å—Ç–∞—ë—Ç—Å—è –≤–Ω–∏–∑—É —Å–∏–ª—É—ç—Ç–∞ (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è)
            const float ShoeY = SilTop + SilHeight - (LabelHeight + BoxHeight); // 720

            // –¢–µ–ª–æ –∏ —à—Ç–∞–Ω—ã –¥–µ–ª—è—Ç –æ—Ç—Ä–µ–∑–æ–∫ [–≥–æ–ª–æ–≤–∞..–æ–±—É–≤—å] –Ω–∞ —Ç—Ä–∏ —Ä–∞–≤–Ω—ã–µ —á–∞—Å—Ç–∏
            const float Segment = (ShoeY - HeadY) / 3.f;
            AddEquipSlot(TEXT("—Ç–µ–ª–æ"), FVector2D(SilCenterX - SlotHalfWidth, HeadY + Segment * 1.f));
            // –ü–µ—Ä—á–∞—Ç–∫–∏ —Å–ø—Ä–∞–≤–∞ –æ—Ç —Å–ª–æ—Ç–∞ "—Ç–µ–ª–æ" –Ω–∞ –æ–¥–Ω–æ–º —É—Ä–æ–≤–Ω–µ
            AddEquipSlot(TEXT("–ø–µ—Ä—á–∞—Ç–∫–∏"), FVector2D(SilCenterX - SlotHalfWidth + 120.f + 20.f, HeadY + Segment * 1.f));
            AddEquipSlot(TEXT("—à—Ç–∞–Ω—ã"), FVector2D(SilCenterX - SlotHalfWidth, HeadY + Segment * 2.f));
            AddEquipSlot(TEXT("–æ–±—É–≤—å"), FVector2D(SilCenterX - SlotHalfWidth, ShoeY));

            // –ë—Ä–æ–Ω–µ–∂–∏–ª–µ—Ç –Ω–∞ —É—Ä–æ–≤–Ω–µ —Å–ª–æ—Ç–∞ "—Ç–µ–ª–æ" (–ø–æ Y –∫–∞–∫ —É —Ç–µ–ª–∞, –ø–æ X –ª–µ–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü)
            AddEquipSlot(TEXT("–±—Ä–æ–Ω–µ–∂–∏–ª–µ—Ç"), FVector2D(60.f, HeadY + Segment * 1.f));
            // –†–∞–∑–≥—Ä—É–∑–∫–∞ —Ä—è–¥–æ–º —Å –±—Ä–æ–Ω–µ–∂–∏–ª–µ—Ç–æ–º - —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É
            UTextBlock* VestLabel = WidgetTree->ConstructWidget<UTextBlock>(UTextBlock::StaticClass());
            VestLabel->SetText(FText::FromString(TEXT("—Ä–∞–∑–≥—Ä—É–∑–∫–∞")));
            VestLabel->SetColorAndOpacity(FSlateColor(FLinearColor::White));
            VestSlotRef = WidgetTree->ConstructWidget<UBorder>(UBorder::StaticClass());
            VestSlotRef->SetBrushColor(FLinearColor(1.f,1.f,1.f,0.05f));
            
            const FVector2D VestPos = FVector2D(60.f, HeadY + Segment * 1.f + 110.f);
            if (UCanvasPanelSlot* VestLabelSlot = Canvas->AddChildToCanvas(VestLabel))
            {
                VestLabelSlot->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                VestLabelSlot->SetAlignment(FVector2D(0.f, 0.f));
                VestLabelSlot->SetPosition(VestPos);
                VestLabelSlot->SetSize(FVector2D(120.f, 20.f));
            }
            if (UCanvasPanelSlot* VestSlotCanvas = Canvas->AddChildToCanvas(VestSlotRef))
            {
                VestSlotCanvas->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                VestSlotCanvas->SetAlignment(FVector2D(0.f, 0.f));
                VestSlotCanvas->SetPosition(VestPos + FVector2D(0.f, 20.f));
                VestSlotCanvas->SetSize(FVector2D(120.f, 80.f));
            }
            // –≠—Ç–∏ –¥–≤–∞ —Å–ª–æ—Ç–∞ –ø–µ—Ä–µ–Ω–µ—Å—ë–º –≤–ø—Ä–∞–≤–æ –æ—Ç –¥–ª–∏–Ω–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤ –æ—Ä—É–∂–∏—è –Ω–∏–∂–µ –ø–æ –∫–æ–¥—É
            
            // –î–ª–∏–Ω–Ω—ã–µ —Å–ª–æ—Ç—ã –ø–æ–¥ —Å–∏–ª—É—ç—Ç–æ–º: –æ—Å–Ω–æ–≤–Ω–æ–µ –æ—Ä—É–∂–∏–µ –∏ –æ—Ä—É–∂–∏–µ –Ω–∞ —Å–ø–∏–Ω–µ
            auto AddWideSlot = [&](const TCHAR* Label, FVector2D Pos, FVector2D Size)
            {
                UTextBlock* WL = WidgetTree->ConstructWidget<UTextBlock>(UTextBlock::StaticClass());
                WL->SetText(FText::FromString(Label));
                WL->SetColorAndOpacity(FSlateColor(FLinearColor::White));
                UBorder* WSlot = WidgetTree->ConstructWidget<UBorder>(UBorder::StaticClass());
                WSlot->SetBrushColor(FLinearColor(1.f,1.f,1.f,0.05f));
                if (UCanvasPanelSlot* WLS = Canvas->AddChildToCanvas(WL))
                {
                    WLS->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                    WLS->SetAlignment(FVector2D(0.f, 0.f));
                    WLS->SetPosition(Pos);
                    WLS->SetSize(FVector2D(Size.X, 20.f));
                }
                if (UCanvasPanelSlot* WSS = Canvas->AddChildToCanvas(WSlot))
                {
                    WSS->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                    WSS->SetAlignment(FVector2D(0.f, 0.f));
                    WSS->SetPosition(Pos + FVector2D(0.f, 20.f));
                    WSS->SetSize(FVector2D(Size.X, Size.Y));
                }
            };
            {
                const float wideX = 40.f; // –ø–æ–¥ —Å–∏–ª—É—ç—Ç–æ–º, –ª–µ–≤–µ–µ –µ–≥–æ
                const float wideYStart = SilTop + SilHeight + 20.f; // —Å—Ä–∞–∑—É –ø–æ–¥ —Å–∏–ª—É—ç—Ç–æ–º
                const FVector2D wideSize(400.f, 80.f); // ¬´–¥–ª–∏–Ω–Ω—ã–π¬ª —Å–ª–æ—Ç (–ø–æ —à–∏—Ä–∏–Ω–µ ~4 –æ–±—ã—á–Ω—ã—Ö —è—á–µ–π–∫–∏)
                AddWideSlot(TEXT("–æ—Å–Ω–æ–≤–Ω–æ–µ –æ—Ä—É–∂–∏–µ"), FVector2D(wideX, wideYStart), wideSize);
                AddWideSlot(TEXT("–æ—Ä—É–∂–∏–µ –Ω–∞ —Å–ø–∏–Ω–µ"), FVector2D(wideX, wideYStart + 120.f), wideSize);

                // –°–ø—Ä–∞–≤–∞ –æ—Ç –¥–ª–∏–Ω–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤ ‚Äî –∫–æ–±—É—Ä–∞ –∏ —Ö–æ–ª–æ–¥–Ω–æ–µ –æ—Ä—É–∂–∏–µ, –æ–¥–∏–Ω –Ω–∞–¥ –¥—Ä—É–≥–∏–º
                const float smallX = wideX + wideSize.X + 20.f;
                const FVector2D smallSize(120.f, 80.f);
                AddEquipSlot(TEXT("–∫–æ–±—É—Ä–∞"), FVector2D(smallX, wideYStart));
                AddEquipSlot(TEXT("—Ö–æ–ª–æ–¥–Ω–æ–µ –æ—Ä—É–∂–∏–µ"), FVector2D(smallX, wideYStart + 120.f));
            }
            
        }
        else
        {
            // –ï—Å–ª–∏ –∫–æ—Ä–µ–Ω—å ‚Äî –Ω–µ Canvas, –¥–æ–±–∞–≤–∏–º –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ –∫–∞–∫ Image
            UImage* BackdropSimple = WidgetTree->ConstructWidget<UImage>(UImage::StaticClass(), TEXT("BackdropSimple"));
            BackdropSimple->SetColorAndOpacity(FLinearColor(0.f, 0.f, 0.f, 0.7f));
            RootPanel->AddChild(BackdropSimple);
        }
    }
}

void UInventoryWidget::NativeConstruct()
{
    Super::NativeConstruct();
    bIsFocusable = true; // –ø—Ä–∏–Ω–∏–º–∞—Ç—å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è
    SetKeyboardFocus();
    SetVisible(false);
    // –ü—Ä–∏ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–µ –Ω–µ –ø–µ—Ä–µ—Å–æ–∑–¥–∞—ë–º –≤–∏–¥–∂–µ—Ç—ã, –∞ –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º—ã–µ ‚Äî —Ä–µ–µ—Å—Ç–∞–≤—Ä–∏—Ä—É–µ–º –ø–æ–∑–∏—Ü–∏–∏ –∏–∑ Placed
    if (RightPanelRef)
    {
        for (const FPlacedItem& P : Placed)
        {
            if (!P.Widget) continue;
            if (UCanvasPanelSlot* S = Cast<UCanvasPanelSlot>(P.Widget->Slot))
            {
                if (GridAreas.IsValidIndex(P.GridIndex))
                {
                    const FGridArea& A = GridAreas[P.GridIndex];
                    const FVector2D CellSize(A.Size.X / FMath::Max(1, A.CellsX), A.Size.Y / FMath::Max(1, A.CellsY));
                    S->SetPosition(A.Position + FVector2D(CellSize.X * P.CellX, CellSize.Y * P.CellY));
                    S->SetSize(FVector2D(60.f * P.SizeX, 60.f * P.SizeY));
                }
            }
        }
    }
}

void UInventoryWidget::SetVisible(bool bIsVisible)
{
	bShown = bIsVisible;
    SetVisibility(bShown ? ESlateVisibility::Visible : ESlateVisibility::Collapsed);
    if (!bShown && WidgetTree && WidgetTree->RootWidget)
    {
        if (UCanvasPanel* Root = Cast<UCanvasPanel>(WidgetTree->RootWidget))
        {
            TArray<UWidget*> Children = Root->GetAllChildren();
            for (UWidget* W : Children)
            {
                if (W && W->GetFName() == TEXT("ContextMenu"))
                {
                    Root->RemoveChild(W);
                    break;
                }
            }
        }
    }
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 2.0f, bShown ? FColor::Green : FColor::Silver, bShown ? TEXT("Inventory visibility: VISIBLE") : TEXT("Inventory visibility: HIDDEN"));
    }
}




    
bool UInventoryWidget::TryAutoPlaceInGrid(int32 GridIndex, int32 SizeX, int32 SizeY, int32& OutCellX, int32& OutCellY) const
    {
        UInventoryItemData* Data = ItMap.Key();
        UInventoryItemWidget* W = ItMap.Value();
        if (!Items.Contains(Data))
        {
            if (GEngine)
            {
                GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Orange, 
                    FString::Printf(TEXT("üóëÔ∏è Removing widget for item: %s"), *Data->DisplayName.ToString()));
            }
            
            // –ù–µ —É–¥–∞–ª—è–µ–º –≤–∏–¥–∂–µ—Ç—ã –∏–∑ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Å–ª–æ—Ç–æ–≤ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏
            if (W && RightPanelRef && !W->bIsStaticEquipmentSlot)
            {
                RightPanelRef->RemoveChild(W);
            }
            ItMap.RemoveCurrent();
        }
    }

    // 2) –°–æ–∑–¥–∞–µ–º –≤–∏–¥–∂–µ—Ç—ã —Ç–æ–ª—å–∫–æ –¥–ª—è –Ω–æ–≤—ã—Ö –ø—Ä–µ–¥–º–µ—Ç–æ–≤. –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–∑–∏—Ü–∏—é —Ä–∞–Ω–µ–µ —Ä–∞–∑–º–µ—â–µ–Ω–Ω—ã—Ö
    for (UInventoryItemData* It : Items)
    {
        // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —ç–∫–∏–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø—Ä–µ–¥–º–µ—Ç—ã - –æ–Ω–∏ –Ω–µ –¥–æ–ª–∂–Ω—ã –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ
        UEquippableItemData* EquippableItem = Cast<UEquippableItemData>(It);
        if (EquippableItem)
        {
            if (GEngine)
            {
                GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Cyan, 
                    FString::Printf(TEXT("üîç Item %s: bIsEquipped = %s"), *It->DisplayName.ToString(), EquippableItem->bIsEquipped ? TEXT("true") : TEXT("false")));
            }
            
            if (EquippableItem->bIsEquipped)
            {
                if (GEngine)
                {
                    GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Yellow, 
                        FString::Printf(TEXT("‚è≠Ô∏è Skipping equipped item in inventory: %s"), *It->DisplayName.ToString()));
                }
                continue;
            }
        }
        
        if (ItemToWidget.Contains(It))
        {
            // –£–∂–µ –µ—Å—Ç—å –≤–∏–¥–∂–µ—Ç ‚Äî —É–±–µ–¥–∏–º—Å—è, —á—Ç–æ –æ–Ω –≤ –Ω—É–∂–Ω–æ–º –≥—Ä–∏–¥–µ –∏ —Ä–∞–∑–º–µ—Ä–µ –ø–æ –¥–∞–Ω–Ω—ã–º —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
            UInventoryItemWidget* W = ItemToWidget[It];
            for (const FPlacedItem& P : Placed)
            {
                if (P.Widget == W)
                {
                    if (UCanvasPanelSlot* S = Cast<UCanvasPanelSlot>(W->Slot))
                    {
                        const FGridArea& A = GridAreas[P.GridIndex];
                        const FVector2D CellSize(A.Size.X / FMath::Max(1, A.CellsX), A.Size.Y / FMath::Max(1, A.CellsY));
                        S->SetPosition(A.Position + FVector2D(CellSize.X * P.CellX, CellSize.Y * P.CellY));
                        S->SetSize(FVector2D(FVector2D(60.f, 60.f) // Default cell size.X * P.SizeX, FVector2D(60.f, 60.f) // Default cell size.Y * P.SizeY));
                    }
                    break;
                }
            }
            continue;
        }

        // –ù–æ–≤—ã–π –ø—Ä–µ–¥–º–µ—Ç ‚Äî —Å–æ–∑–¥–∞—ë–º –∏ –∞–≤—Ç–æ—Ä–∞–∑–º–µ—â–∞–µ–º
        int32 SX = It ? FMath::Max(1, It->SizeInCellsX) : 1;
        int32 SY = It ? FMath::Max(1, It->SizeInCellsY) : 1;
        int32 CellX, CellY;
        const int32 GridIndex = false // Backpack grid removedIndex;
        if (TryAutoPlaceInGrid(GridIndex, SX, SY, CellX, CellY))
        {
            UInventoryItemWidget* ItemW = WidgetTree->ConstructWidget<UInventoryItemWidget>(UInventoryItemWidget::StaticClass());
            UTexture2D* Icon = (It && It->Icon) ? It->Icon : LoadObject<UTexture2D>(nullptr, TEXT("/Engine/EngineResources/WhiteSquareTexture.WhiteSquareTexture"));
            ItemW->Init(It, Icon, FVector2D(60.f, 60.f) // Default cell size);
            const FGridArea& A = GridAreas[GridIndex];
            const FVector2D CellSize(A.Size.X / FMath::Max(1, A.CellsX), A.Size.Y / FMath::Max(1, A.CellsY));
            const FVector2D Pos = A.Position + FVector2D(CellX * CellSize.X, CellY * CellSize.Y);
            if (UCanvasPanelSlot* S = RightPanelRef->AddChildToCanvas(ItemW))
            {
                S->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                S->SetAlignment(FVector2D(0.f, 0.f));
                S->SetPosition(Pos);
                S->SetSize(FVector2D(60.f * SX, 60.f * SY));
                S->SetZOrder(5);
                ItemToWidget.Add(It, ItemW);
                UpsertPlacement(ItemW, GridIndex, CellX, CellY);
            }
        }
    }
}
bool UInventoryWidget::TryAutoPlaceInGrid(int32 GridIndex, int32 SizeX, int32 SizeY, int32& OutCellX, int32& OutCellY) const
{
    if (!GridAreas.IsValidIndex(GridIndex)) return false;
    const FGridArea& A = GridAreas[GridIndex];
    for (int32 y = 0; y < A.CellsY; ++y)
    {
        for (int32 x = 0; x < A.CellsX; ++x)
        {
            if (IsAreaFree(GridIndex, x, y, SizeX, SizeY, nullptr))
            {
                OutCellX = x; OutCellY = y; return true;
            }
        }
    }
    return false;
}

void UInventoryWidget::RegisterGrid(const FString& Name, const FVector2D& Pos, const FVector2D& Size, int32 CellsX, int32 CellsY)
{
    FGridArea A; A.Name=Name; A.Position=Pos; A.Size=Size; A.CellsX=CellsX; A.CellsY=CellsY; GridAreas.Add(A);
}

int32 UInventoryWidget::FindGridAtPoint(const FVector2D& LocalPoint) const
{
    for (int32 i=0;i<GridAreas.Num();++i)
    {
        const FGridArea& A = GridAreas[i];
        const FVector2D P = LocalPoint - A.Position;
        if (P.X>=0 && P.Y>=0 && P.X<A.Size.X && P.Y<A.Size.Y)
        {
            return i;
        }
    }
    return INDEX_NONE;
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –ø–æ–∏—Å–∫ –∏–Ω–¥–µ–∫—Å–∞ –≥—Ä–∏–¥–∞ –∂–∏–ª–µ—Ç–∞ –ø–æ —Ä–µ–∞–ª—å–Ω—ã–º —Å–ª–æ—Ç–∞–º, –µ—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ GridAreas
static int32 FindVestGridByWidgets(const UCanvasPanel* RightPanel, const TArray<UCanvasPanel*>& VestGrids, const FVector2D& PanelLocal)
{
    if (!RightPanel) return INDEX_NONE;
    for (int32 gi = 0; gi < VestGrids.Num(); ++gi)
    {
        const UCanvasPanel* Grid = VestGrids[gi];
        if (!Grid) continue;
        if (const UCanvasPanelSlot* GS = Cast<UCanvasPanelSlot>(Grid->Slot))
        {
            const FVector2D Pos = GS->GetPosition();
            const FVector2D Size = GS->GetSize();
            const FVector2D P = PanelLocal - Pos;
            if (P.X >= 0.f && P.Y >= 0.f && P.X < Size.X && P.Y < Size.Y)
            {
                return gi; // –ü–æ—Ä—è–¥–æ–∫ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≥—Ä–∏–¥–∞ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –ø–æ—Ä—è–¥–∫–æ–º —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ GridAreas
            }
        }
    }
    return INDEX_NONE;
}

static bool PlaceItemIntoVestGridWidget(UCanvasPanel* TargetGrid, UInventoryItemWidget* ItemWidget, int32 CellsX, int32 CellsY)
{
    if (!TargetGrid || !ItemWidget) return false;
    // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –≤–∏–¥–∂–µ—Ç –≤–Ω—É—Ç—Ä—å –≥—Ä–∏–¥–∞ –∏ —Å—Ç–∞–≤–∏–º –≤ (0,0) —Å —É—á—ë—Ç–æ–º —è—á–µ–µ–∫
    if (UCanvasPanelSlot* NewSlot = TargetGrid->AddChildToCanvas(ItemWidget))
    {
        if (UCanvasPanelSlot* GridSlot = Cast<UCanvasPanelSlot>(TargetGrid->Slot))
        {
            const FVector2D GridSize = GridSlot->GetSize();
            const FVector2D CellSize(GridSize.X / FMath::Max(1, CellsX), GridSize.Y / FMath::Max(1, CellsY));
            const int32 SX = ItemWidget->bRotated ? ItemWidget->SizeY : ItemWidget->SizeX;
            const int32 SY = ItemWidget->bRotated ? ItemWidget->SizeX : ItemWidget->SizeY;
            NewSlot->SetPosition(FVector2D(0.f, 0.f));
            NewSlot->SetSize(FVector2D(CellSize.X * SX, CellSize.Y * SY));
            if (GEngine)
            {
                const FString ParentName = TargetGrid->GetName();
                GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Green,
                    FString::Printf(TEXT("üì• PlacedInVest Parent=%s Pos(0,0) Size(%.0f,%.0f) Cell(%.0f,%.0f)"),
                        *ParentName, CellSize.X * SX, CellSize.Y * SY, CellSize.X, CellSize.Y));
            }
            return true;
        }
    }
    return false;
}

FVector2D UInventoryWidget::SnapToCellInGrid(int32 GridIndex, const FVector2D& LocalPoint) const
{
    const FGridArea& A = GridAreas[GridIndex];
    FVector2D P = LocalPoint - A.Position;
    const FVector2D CellSize(A.Size.X / FMath::Max(1, A.CellsX), A.Size.Y / FMath::Max(1, A.CellsY));
    const int32 X = FMath::Clamp((int32)FMath::FloorToInt(P.X / CellSize.X), 0, A.CellsX-1);
    const int32 Y = FMath::Clamp((int32)FMath::FloorToInt(P.Y / CellSize.Y), 0, A.CellsY-1);
    return A.Position + FVector2D(X * CellSize.X, Y * CellSize.Y);
}


// –£–¥–∞–ª—ë–Ω —Ä–∞–Ω–Ω–∏–π –∑–∞–≥–ª—É—à–µ—á–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ NativeOnDragOver (–∑–∞–º–µ–Ω—ë–Ω –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π –Ω–∏–∂–µ)

bool UInventoryWidget::NativeOnDrop(const FGeometry& InGeometry, const FDragDropEvent& InDragDropEvent, UDragDropOperation* InOperation)
{
    if (!RightPanelRef || !InOperation) return false;
    
    // –ü–µ—Ä–µ–≤–æ–¥–∏–º –≤ –ª–æ–∫–∞–ª—å–Ω—ã–µ RightPanel –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é RightPanelRef –¥–ª—è —Ç–æ—á–Ω—ã—Ö –ª–æ–∫–∞–ª—å–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
    const FGeometry& PanelGeom = RightPanelRef->GetCachedGeometry();
    const FVector2D PanelLocal = PanelGeom.AbsoluteToLocal(InDragDropEvent.GetScreenSpacePosition());
    int32 GridIndex = FindGridAtPoint(PanelLocal);
    if (GridIndex == INDEX_NONE) 
    {
        // –§–æ–ª–±—ç–∫: –∏—â–µ–º –ø–æ —Ä–µ–∞–ª—å–Ω—ã–º —Å–ª–æ—Ç–∞–º –≥—Ä–∏–¥–æ–≤ –∂–∏–ª–µ—Ç–∞
        const int32 VestIdx = FindVestGridByWidgets(RightPanelRef, VestGrids, PanelLocal);
        if (VestIdx != INDEX_NONE)
        {
            // –ù–∞–π–¥—ë–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –∏–Ω–¥–µ–∫—Å –≤ GridAreas –ø–æ –∏–º–µ–Ω–∏
            const FString VestName = FString::Printf(TEXT("–∂–∏–ª–µ—Ç%d"), VestIdx+1);
            for (int32 i=0;i<GridAreas.Num();++i)
            {
                if (GridAreas[i].Name == VestName) { GridIndex = i; break; }
            }
        }
        if (GridIndex == INDEX_NONE)
        {
        if (Highlight) { RightPanelRef->RemoveChild(Highlight); Highlight = nullptr; }
        DragItem = nullptr;
        bDragActive = false;
        return false;
        }
    }
    
    if (UWidget* W = Cast<UWidget>(InOperation->Payload))
    {
        if (UCanvasPanelSlot* S = Cast<UCanvasPanelSlot>(W->Slot))
        {
            DragItem = Cast<UInventoryItemWidget>(W);
            if (!DragItem) return false;
            
            // –ó–∞–ø–æ–º–Ω–∏–º —Å—Ç–∞—Ä—Ç–æ–≤–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –Ω–∞ —Å–ª—É—á–∞–π –æ—Ç–º–µ–Ω—ã
            DragStartPos = S->GetPosition();
            DragStartSize = S->GetSize();
            if (GEngine)
            {
                const FString ParentName = S->Parent ? S->Parent->GetName() : TEXT("<no-parent>");
                GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Silver,
                    FString::Printf(TEXT("‚¨ÖÔ∏è StartDrag Parent=%s Pos(%.0f,%.0f) Size(%.0f,%.0f)"),
                        *ParentName, DragStartPos.X, DragStartPos.Y, DragStartSize.X, DragStartSize.Y));
            }
            
            const FVector2D LocalInGrid = PanelLocal - GridAreas[GridIndex].Position;
            const FVector2D CellSize = FVector2D(
                GridAreas[GridIndex].Size.X / FMath::Max(1, GridAreas[GridIndex].CellsX),
                GridAreas[GridIndex].Size.Y / FMath::Max(1, GridAreas[GridIndex].CellsY)
            );
            
            int32 CellX = FMath::FloorToInt(LocalInGrid.X / CellSize.X);
            int32 CellY = FMath::FloorToInt(LocalInGrid.Y / CellSize.Y);
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –≥—Ä–∏–¥–∞
            CellX = FMath::Clamp(CellX, 0, GridAreas[GridIndex].CellsX - 1);
            CellY = FMath::Clamp(CellY, 0, GridAreas[GridIndex].CellsY - 1);
            
            int32 SX = DragItem->bRotated ? DragItem->SizeY : DragItem->SizeX;
            int32 SY = DragItem->bRotated ? DragItem->SizeX : DragItem->SizeY;
            
            // –ï—Å–ª–∏ —ç—Ç–æ –≥—Ä–∏–¥ –∂–∏–ª–µ—Ç–∞, –ø—Ä–æ–±—É–µ–º –∞–≤—Ç–æ-–ø–æ–≤–µ—Ä–Ω—É—Ç—å –ø—Ä–µ–¥–º–µ—Ç –ø–æ–¥ —Ä–∞–∑–º–µ—Ä –∫–∞—Ä–º–∞–Ω–∞
            if (GridAreas.IsValidIndex(GridIndex))
            {
                const FGridArea& Target = GridAreas[GridIndex];
                if (Target.Name.StartsWith(TEXT("–∂–∏–ª–µ—Ç")))
                {
                    const int32 AllowedX = Target.CellsX; // 1
                    const int32 AllowedY = Target.CellsY; // 1 –∏–ª–∏ 2
                    const bool Fits = (SX <= AllowedX && SY <= AllowedY);
                    const bool FitsRotated = (SY <= AllowedX && SX <= AllowedY);
                    if (!Fits && FitsRotated && DragItem->ItemData && DragItem->ItemData->bRotatable)
                    {
                        // –ü–æ–≤–µ—Ä–Ω—ë–º, —á—Ç–æ–±—ã –≤–ª–µ–∑–ª–æ
                        DragItem->bRotated = !DragItem->bRotated;
                        SX = DragItem->bRotated ? DragItem->SizeY : DragItem->SizeX;
                        SY = DragItem->bRotated ? DragItem->SizeX : DragItem->SizeY;
                        DragItem->UpdateVisualSize(FVector2D(60.f, 60.f) // Default cell size);
                    }
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–º–µ—â–∞–µ—Ç—Å—è –ª–∏ –ø—Ä–µ–¥–º–µ—Ç –≤ –≤—ã–±—Ä–∞–Ω–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
            if (!IsAreaFree(GridIndex, CellX, CellY, SX, SY, DragItem))
            {
                // –ü–æ–ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –±–ª–∏–∂–∞–π—à–µ–µ —Å–≤–æ–±–æ–¥–Ω–æ–µ –º–µ—Å—Ç–æ
                int32 AutoX, AutoY;
                if (TryAutoPlaceInGrid(GridIndex, SX, SY, AutoX, AutoY))
                {
                    CellX = AutoX; 
                    CellY = AutoY;
                }
                else
                {
                    // –ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ ‚Äî –≤–µ—Ä–Ω—É—Ç—å –Ω–∞–∑–∞–¥
                    DragItem->SetTint(FLinearColor::White);
                    S->SetPosition(DragStartPos);
                    S->SetSize(DragStartSize);
                    if (Highlight) { RightPanelRef->RemoveChild(Highlight); Highlight = nullptr; }
                    DragItem = nullptr;
                    bDragActive = false;
                    return false;
                }
            }
            
            // –¶–µ–ª–µ–≤–æ–π –≥—Ä–∏–¥
            const FGridArea& TargetArea = GridAreas[GridIndex];
            const bool bIsVestGrid = TargetArea.Name.StartsWith(TEXT("–∂–∏–ª–µ—Ç"));
            if (bIsVestGrid)
            {
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –≥–¥–µ —Å–µ–π—á–∞—Å –ª–µ–∂–∏—Ç –ø—Ä–µ–¥–º–µ—Ç: –≤ —Ä—é–∫–∑–∞–∫–µ –∏–ª–∏ —É–∂–µ –≤ –∂–∏–ª–µ—Ç–µ
                APlayerCharacter* PlayerChar = Cast<APlayerCharacter>(GetOwningPlayerPawn());
                if (PlayerChar && PlayerChar->InventoryComponent)
                {
                    UInventoryComponent* InvComp = PlayerChar->InventoryComponent;
                    UEquippableItemData* EquippedVest = InvComp->GetEquippedItem(Vest);
                    if (EquippedVest && EquippedVest->bHasAdditionalStorage)
                    {
                        const bool bInBackpack = InvComp->BackpackItems.Contains(DragItem->ItemData);
                        if (bInBackpack)
                        {
                            // –£–¥–∞–ª—è–µ–º –∏–∑ —Ä—é–∫–∑–∞–∫–∞ –∏ –¥–æ–±–∞–≤–ª—è–µ–º –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –∂–∏–ª–µ—Ç–∞
                            InvComp->RemoveSpecificFromBackpack(DragItem->ItemData);
                            InvComp->AddToEquipmentStorage(EquippedVest, DragItem->ItemData);
                        }
                        else
                        {
                            // –ü—Ä–µ–¥–º–µ—Ç —É–∂–µ –≤ –∂–∏–ª–µ—Ç–µ –∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ—Ç—Å—è –º–µ–∂–¥—É –∫–∞—Ä–º–∞–Ω–∞–º–∏: –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ—Å—Ç–∞–≤–ª—è–µ–º –≤–∏–¥–∂–µ—Ç
                        }
                        // –ù–∞–π–¥—ë–º –∏–Ω–¥–µ–∫—Å –≥—Ä–∏–¥–∞ –∂–∏–ª–µ—Ç–∞ 0..5
                        int32 VestIdx = 0;
                        {
                            // –ò–º—è —Ñ–æ—Ä–º–∞—Ç–∞ "–∂–∏–ª–µ—ÇN"
                            const FString& N = TargetArea.Name;
                            FString Digits;
                            for (int32 i = 0; i < N.Len(); ++i) { if (FChar::IsDigit(N[i])) { Digits.AppendChar(N[i]); } }
                            VestIdx = FMath::Max(1, FCString::Atoi(*Digits)) - 1;
                        }
                        if (VestGrids.IsValidIndex(VestIdx))
                        {
                            UCanvasPanel* TargetGrid = VestGrids[VestIdx];
                            const int32 CellsX = TargetArea.CellsX;
                            const int32 CellsY = TargetArea.CellsY;
                            // –í–ê–ñ–ù–û: —Å–Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µ–Ω–æ—Å–∏–º –≤–∏–∑—É–∞–ª—å–Ω–æ, –∑–∞—Ç–µ–º –Ω–µ –≤—ã–∑—ã–≤–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π UpdateVestGrid, —á—Ç–æ–±—ã –Ω–µ —É–¥–∞–ª—è—Ç—å –Ω–æ–≤—ã–π –≤–∏–¥–∂–µ—Ç
                            if (PlaceItemIntoVestGridWidget(TargetGrid, DragItem, CellsX, CellsY))
                            {
                                DragItem->bIsStaticEquipmentSlot = true; // —á—Ç–æ–±—ã SyncBackpack –Ω–µ —É–¥–∞–ª–∏–ª
                                // –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –∏–∑ —Å–ø–∏—Å–∫–∞ Placed (–æ–Ω–∞ –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ —Ä—é–∫–∑–∞–∫—É)
                                for (int32 i = Placed.Num()-1; i >= 0; --i)
                                {
                                    if (Placed[i].Widget == DragItem) { Placed.RemoveAt(i); }
                                }
            DragItem->SetTint(FLinearColor::White);
                                if (Highlight) { RightPanelRef->RemoveChild(Highlight); Highlight = nullptr; }
                                DragItem = nullptr; bDragActive = false;
                                // –õ—ë–≥–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞–Ω–µ–ª–∏, –±–µ–∑ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä–∏–¥–æ–≤
                                if (RightPanelRef) { RightPanelRef->InvalidateLayoutAndVolatility(); }
                                return true;
                            }
                        }
                    }
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥—Ä–æ–ø–∞–µ–º –ª–∏ –≤ —Ä—é–∫–∑–∞–∫
            const bool bIsfalse // Backpack grid removed = TargetArea.Name.StartsWith(TEXT("—Ä—é–∫–∑–∞–∫"));
            if (bIsfalse // Backpack grid removed)
            {
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –≥–¥–µ —Å–µ–π—á–∞—Å –ª–µ–∂–∏—Ç –ø—Ä–µ–¥–º–µ—Ç: –≤ —Ä—é–∫–∑–∞–∫–µ –∏–ª–∏ —É–∂–µ –≤ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–µ
                APlayerCharacter* PlayerChar = Cast<APlayerCharacter>(GetOwningPlayerPawn());
                if (PlayerChar && PlayerChar->InventoryComponent)
                {
                    UInventoryComponent* InvComp = PlayerChar->InventoryComponent;
                    UEquippableItemData* EquippedBackpack = InvComp->GetEquippedItem(Backpack);
                    if (EquippedBackpack && EquippedBackpack->bHasAdditionalStorage)
                    {
                        const bool bInBackpack = InvComp->BackpackItems.Contains(DragItem->ItemData);
                        if (bInBackpack)
                        {
                            // –£–¥–∞–ª—è–µ–º –∏–∑ —Ä—é–∫–∑–∞–∫–∞ –∏ –¥–æ–±–∞–≤–ª—è–µ–º –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ —Ä—é–∫–∑–∞–∫–∞
                            InvComp->RemoveSpecificFromBackpack(DragItem->ItemData);
                            InvComp->AddToEquipmentStorage(EquippedBackpack, DragItem->ItemData);
                        }
                        else
                        {
                            // –ü—Ä–µ–¥–º–µ—Ç —É–∂–µ –≤ —Ä—é–∫–∑–∞–∫–µ –∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ—Ç—Å—è –≤–Ω—É—Ç—Ä–∏: –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ—Å—Ç–∞–≤–ª—è–µ–º –≤–∏–¥–∂–µ—Ç
                        }
                        
                        if (false // Backpack grid removed)
                        {
                            const int32 CellsX = TargetArea.CellsX;
                            const int32 CellsY = TargetArea.CellsY;
                            if (PlaceItemIntofalse // Backpack grid removedWidget(false // Backpack grid removed, DragItem, CellsX, CellsY))
                            {
                                DragItem->bIsStaticEquipmentSlot = true; // —á—Ç–æ–±—ã SyncBackpack –Ω–µ —É–¥–∞–ª–∏–ª
                                // –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –∏–∑ —Å–ø–∏—Å–∫–∞ Placed (–æ–Ω–∞ –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ —Ä—é–∫–∑–∞–∫—É)
                                for (int32 i = Placed.Num()-1; i >= 0; --i)
                                {
                                    if (Placed[i].Widget == DragItem) { Placed.RemoveAt(i); }
                                }
                                DragItem->SetTint(FLinearColor::White);
            if (Highlight) { RightPanelRef->RemoveChild(Highlight); Highlight = nullptr; }
                                DragItem = nullptr; bDragActive = false;
                                // –õ—ë–≥–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞–Ω–µ–ª–∏, –±–µ–∑ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä–∏–¥–∞
                                if (RightPanelRef) { RightPanelRef->InvalidateLayoutAndVolatility(); }
            return true;
                            }
                        }
                    }
                }
            }
            
            // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∫–∞–∫ –∂–∏–ª–µ—Ç –∏–ª–∏ —Ä—é–∫–∑–∞–∫ ‚Äî –æ—Ç–∫–∞—Ç
            DragItem->SetTint(FLinearColor::White);
            S->SetPosition(DragStartPos);
            S->SetSize(DragStartSize);
            if (Highlight) { RightPanelRef->RemoveChild(Highlight); Highlight = nullptr; }
            DragItem = nullptr; bDragActive = false; return false;
        }
    }
    
    // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏ –Ω–µ—É–¥–∞—á–Ω–æ–º –¥—Ä–æ–ø–µ
    if (Highlight) { RightPanelRef->RemoveChild(Highlight); Highlight = nullptr; }
    DragItem = nullptr;
    bDragActive = false;
    return false;
}



FReply UInventoryWidget::NativeOnKeyDown(const FGeometry& InGeometry, const FKeyEvent& InKeyEvent)
{
    // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º Ctrl/Shift –≤ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞, –¥–∞–∂–µ –∫–æ–≥–¥–∞ —Ñ–æ–∫—É—Å –Ω–∞ –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ
    const FKey Key = InKeyEvent.GetKey();
    if (Key == EKeys::LeftControl)
    {
        if (APlayerController* PC = GetOwningPlayer())
        {
            if (ABTZBaseCharacter* Ch = Cast<ABTZBaseCharacter>(PC->GetPawn()))
            {
                if (GEngine) GEngine->AddOnScreenDebugMessage(-1, 1.5f, FColor::Cyan, TEXT("UI: Ctrl -> ChangeCrouchState"));
                Ch->ChangeCrouchState();
                return FReply::Handled();
            }
        }
    }
    if (Key == EKeys::LeftShift)
    {
        if (APlayerController* PC = GetOwningPlayer())
        {
            if (ABTZBaseCharacter* Ch = Cast<ABTZBaseCharacter>(PC->GetPawn()))
            {
                if (GEngine) GEngine->AddOnScreenDebugMessage(-1, 1.5f, FColor::Cyan, TEXT("UI: Shift -> ChangeProneState"));
                Ch->ChangeProneState();
                return FReply::Handled();
            }
        }
    }
    return HandleItemRotation(InGeometry, InKeyEvent);
}

FReply UInventoryWidget::HandleItemRotation(const FGeometry& InGeometry, const FKeyEvent& InKeyEvent)
{
    if (InKeyEvent.GetKey() == EKeys::R)
    {
        // –í—Ä–∞—â–µ–Ω–∏–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç–∞
        if (DragItem && DragItem->ItemData && DragItem->ItemData->bRotatable)
        {
            DragItem->bRotated = !DragItem->bRotated;
            DragItem->UpdateVisualSize(FVector2D(60.f, 60.f) // Default cell size);
            return FReply::Handled();
        }
        
        // –í—Ä–∞—â–µ–Ω–∏–µ –ø—Ä–µ–¥–º–µ—Ç–∞ –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
        if (HoverItem && HoverItem->ItemData && HoverItem->ItemData->bRotatable)
        {
            // –ù–∞—Ö–æ–¥–∏–º –∑–∞–ø–∏—Å—å –æ —Ä–∞–∑–º–µ—â–µ–Ω–∏–∏ –ø—Ä–µ–¥–º–µ—Ç–∞
            FPlacedItem* PlacedItem = nullptr;
            for (FPlacedItem& P : Placed)
            {
                if (P.Widget == HoverItem)
                {
                    PlacedItem = &P;
                    break;
                }
            }
            
            if (PlacedItem)
            {
                // –í—Ä–µ–º–µ–Ω–Ω–æ –≤—Ä–∞—â–∞–µ–º –ø—Ä–µ–¥–º–µ—Ç
                HoverItem->bRotated = !HoverItem->bRotated;
                int32 SX = HoverItem->bRotated ? HoverItem->SizeY : HoverItem->SizeX;
                int32 SY = HoverItem->bRotated ? HoverItem->SizeX : HoverItem->SizeY;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–º–µ—â–∞–µ—Ç—Å—è –ª–∏ –ø—Ä–µ–¥–º–µ—Ç –≤ –Ω–æ–≤–æ–º –ø–æ–ª–æ–∂–µ–Ω–∏–∏
                if (IsAreaFree(PlacedItem->GridIndex, PlacedItem->CellX, PlacedItem->CellY, SX, SY, HoverItem))
                {
                    // –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å –æ —Ä–∞–∑–º–µ—â–µ–Ω–∏–∏
                    PlacedItem->SizeX = SX;
                    PlacedItem->SizeY = SY;
                    PlacedItem->bRotated = HoverItem->bRotated;
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
                    HoverItem->UpdateVisualSize(FVector2D(60.f, 60.f) // Default cell size);
                    if (UCanvasPanelSlot* S = Cast<UCanvasPanelSlot>(HoverItem->Slot))
                    {
                        const FGridArea& A = GridAreas[PlacedItem->GridIndex];
                        const FVector2D CellSize = FVector2D(
                            A.Size.X / FMath::Max(1, A.CellsX),
                            A.Size.Y / FMath::Max(1, A.CellsY)
                        );
                        S->SetSize(FVector2D(FVector2D(60.f, 60.f) // Default cell size.X * SX, FVector2D(60.f, 60.f) // Default cell size.Y * SY));
                        S->SetPosition(A.Position + FVector2D(CellSize.X * PlacedItem->CellX, CellSize.Y * PlacedItem->CellY));
                    }
                }
                else
                {
                    // –û—Ç–∫–∞—Ç—ã–≤–∞–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ –µ—Å–ª–∏ –Ω–µ –ø–æ–º–µ—â–∞–µ—Ç—Å—è
                    HoverItem->bRotated = !HoverItem->bRotated;
                    HoverItem->UpdateVisualSize(FVector2D(60.f, 60.f) // Default cell size);
                }
            }
            return FReply::Handled();
        }
    }
    return FReply::Unhandled();
}

bool UInventoryWidget::NativeOnDragOver(const FGeometry& InGeometry, const FDragDropEvent& InDragDropEvent, UDragDropOperation* InOperation)
{
    if (!RightPanelRef || !InOperation) return false;
    
    const FGeometry& PanelGeom = RightPanelRef->GetCachedGeometry();
    const FVector2D PanelLocal = PanelGeom.AbsoluteToLocal(InDragDropEvent.GetScreenSpacePosition());
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Cyan,
            FString::Printf(TEXT("üñ± PanelLocal: (%.0f,%.0f)"), PanelLocal.X, PanelLocal.Y));
    }
    int32 GridIndex = FindGridAtPoint(PanelLocal);
    UInventoryItemWidget* Item = Cast<UInventoryItemWidget>(InOperation->Payload);
    
    if (GridIndex == INDEX_NONE)
    {
        // –§–æ–ª–±—ç–∫ –¥–ª—è –∂–∏–ª–µ—Ç–∞ –ø–æ —Ä–µ–∞–ª—å–Ω—ã–º —Å–ª–æ—Ç–∞–º
        const int32 VestIdx = FindVestGridByWidgets(RightPanelRef, VestGrids, PanelLocal);
        if (VestIdx != INDEX_NONE)
        {
            const FString VestName = FString::Printf(TEXT("–∂–∏–ª–µ—Ç%d"), VestIdx+1);
            for (int32 i=0;i<GridAreas.Num();++i)
            {
                if (GridAreas[i].Name == VestName) { GridIndex = i; break; }
            }
            if (GEngine && VestGrids.IsValidIndex(VestIdx))
            {
                if (const UCanvasPanelSlot* GS = Cast<UCanvasPanelSlot>(VestGrids[VestIdx]->Slot))
                {
                    GEngine->AddOnScreenDebugMessage(-1, 1.5f, FColor::Yellow,
                        FString::Printf(TEXT("üß© VestSlot[%d] Pos(%.0f,%.0f) Size(%.0f,%.0f)"), VestIdx+1,
                            GS->GetPosition().X, GS->GetPosition().Y, GS->GetSize().X, GS->GetSize().Y));
                }
            }
        }
    }
    
    if (GridIndex == INDEX_NONE || !Item) 
    { 
        if (Highlight) { RightPanelRef->RemoveChild(Highlight); Highlight = nullptr; } 
        return false; 
    }

    const FGridArea& A = GridAreas[GridIndex];
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Green,
            FString::Printf(TEXT("üìê Grid '%s' Pos(%.0f,%.0f) Size(%.0f,%.0f)"), *A.Name, A.Position.X, A.Position.Y, A.Size.X, A.Size.Y));
    }
    const FVector2D LocalInGrid = PanelLocal - A.Position;
    const FVector2D CellSize = FVector2D(
        A.Size.X / FMath::Max(1, A.CellsX),
        A.Size.Y / FMath::Max(1, A.CellsY)
    );
    
    int32 CellX = FMath::FloorToInt(LocalInGrid.X / CellSize.X);
    int32 CellY = FMath::FloorToInt(LocalInGrid.Y / CellSize.Y);
    
    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –≥—Ä–∏–¥–∞
    CellX = FMath::Clamp(CellX, 0, A.CellsX - 1);
    CellY = FMath::Clamp(CellY, 0, A.CellsY - 1);
    
    int32 SX = Item->bRotated ? Item->SizeY : Item->SizeX;
    int32 SY = Item->bRotated ? Item->SizeX : Item->SizeY;
    
    bool bFree = IsAreaFree(GridIndex, CellX, CellY, SX, SY, Item);
    int32 AutoX, AutoY;
    if (!bFree && TryAutoPlaceInGrid(GridIndex, SX, SY, AutoX, AutoY))
    {
        bFree = true; 
        CellX = AutoX; 
        CellY = AutoY;
    }

    // –°–æ–∑–¥–∞—ë–º/–æ–±–Ω–æ–≤–ª—è–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É —è—á–µ–µ–∫
    if (!Highlight)
    {
        Highlight = WidgetTree->ConstructWidget<UBorder>(UBorder::StaticClass());
        if (UCanvasPanelSlot* HS = RightPanelRef->AddChildToCanvas(Highlight))
        {
            HS->SetZOrder(6);
        }
    }
    
    if (Highlight)
    {
        Highlight->SetBrushColor(bFree ? FLinearColor(0.f, 1.f, 0.f, 0.25f) : FLinearColor(1.f, 0.f, 0.f, 0.25f));
        if (UCanvasPanelSlot* HS = Cast<UCanvasPanelSlot>(Highlight->Slot))
        {
            HS->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f)); 
            HS->SetAlignment(FVector2D(0.f, 0.f));
            const FVector2D FinalPos = A.Position + FVector2D(CellX * CellSize.X, CellY * CellSize.Y);
            HS->SetPosition(FinalPos);
            HS->SetSize(FVector2D(FVector2D(60.f, 60.f) // Default cell size.X * SX, FVector2D(60.f, 60.f) // Default cell size.Y * SY));
            if (GEngine)
            {
                GEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Emerald,
                    FString::Printf(TEXT("üü© Highlight Pos(%.0f,%.0f) Cell(%.0f,%.0f)"), FinalPos.X, FinalPos.Y, CellSize.X, CellSize.Y));
            }
        }
    }
    
    // –¢–æ–Ω–∏—Ä—É–µ–º —Å–∞–º –ø—Ä–µ–¥–º–µ—Ç
    Item->SetTint(bFree ? FLinearColor(1.f, 1.f, 1.f, 1.f) : FLinearColor(1.f, 0.2f, 0.2f, 1.f));
    DragItem = Item;
    bDragActive = true;
    return true;
}

void UInventoryWidget::NativeOnDragCancelled(const FDragDropEvent& InDragDropEvent, UDragDropOperation* InOperation)
{
    if (!bDragActive) return;
    if (DragItem)
    {
        if (UCanvasPanelSlot* S = Cast<UCanvasPanelSlot>(DragItem->Slot))
        {
            S->SetPosition(DragStartPos);
            S->SetSize(DragStartSize);
        }
        DragItem->SetTint(FLinearColor::White);
    }
    if (Highlight) { RightPanelRef->RemoveChild(Highlight); Highlight=nullptr; }
    DragItem = nullptr;
    bDragActive = false;
}

void UInventoryWidget::UpdateEquipmentSlots()
{
    if (!EquipmentPanelRef) 
    {
        if (GEngine) GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Red, TEXT("‚ùå UpdateEquipmentSlots: EquipmentPanelRef is null"));
        return;
    }
    
    if (GEngine) GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Cyan, TEXT("üîß UpdateEquipmentSlots called"));
    
    // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –≤–∏–¥–∂–µ—Ç—ã —Å–ª–æ—Ç–æ–≤ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏
    if (EquipmentPanelRef)
    {
        // –£–¥–∞–ª—è–µ–º –≤—Å–µ –¥–æ—á–µ—Ä–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã –ø–∞–Ω–µ–ª–∏ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏
        TArray<UWidget*> Children = EquipmentPanelRef->GetAllChildren();
        for (UWidget* Child : Children)
        {
            EquipmentPanelRef->RemoveChild(Child);
        }
    }
    EquipmentSlotWidgets.Empty();
    
    // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏ –æ—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
    APlayerController* PC = GetOwningPlayer();
    if (!PC) return;
    
    APlayerCharacter* PlayerChar = Cast<APlayerCharacter>(PC->GetPawn());
    if (!PlayerChar || !PlayerChar->InventoryComponent) return;
    
    UInventoryComponent* InvComp = PlayerChar->InventoryComponent;
    
    // –°–æ–∑–¥–∞–µ–º –≤–∏–¥–∂–µ—Ç—ã –¥–ª—è —Å–ª–æ—Ç–æ–≤ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏
    TArray<TEnumAsByte<EEquipmentSlotType>> SlotTypes = {
        Helmet,
        Vest,
        Backpack,
        PrimaryWeapon,
        SecondaryWeapon,
        Melee
    };
    
    TArray<FString> SlotNames = {
        TEXT("–ì–æ–ª–æ–≤–∞"),
        TEXT("–†–∞–∑–≥—Ä—É–∑–∫–∞"),
        TEXT("–†—é–∫–∑–∞–∫"),
        TEXT("–û—Å–Ω–æ–≤–Ω–æ–µ –æ—Ä—É–∂–∏–µ"),
        TEXT("–í—Ç–æ—Ä–∏—á–Ω–æ–µ –æ—Ä—É–∂–∏–µ"),
        TEXT("–•–æ–ª–æ–¥–Ω–æ–µ –æ—Ä—É–∂–∏–µ")
    };
    
    // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ç–æ–ª—å–∫–æ —Å–ª–æ—Ç "–†–∞–∑–≥—Ä—É–∑–∫–∞" –¥–ª—è –∂–∏–ª–µ—Ç–∞
    for (int32 i = 0; i < SlotTypes.Num(); ++i)
    {
        EEquipmentSlotType SlotType = SlotTypes[i];
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Å–ª–æ—Ç—ã Vest (–†–∞–∑–≥—Ä—É–∑–∫–∞) –∏ Backpack (–†—é–∫–∑–∞–∫)
        if (SlotType != Vest && SlotType != Backpack) continue;
        
        UEquippableItemData* EquippedItem = InvComp->GetEquippedItem(SlotType);
        
        // –°–æ–∑–¥–∞–µ–º –≤–∏–¥–∂–µ—Ç —Å–ª–æ—Ç–∞ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏
        CreateEquipmentSlotWidget(EquippedItem, i, SlotNames[i], SlotType);
        
        if (EquippedItem)
        {
            if (GEngine)
            {
                GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Green, 
                    FString::Printf(TEXT("‚úÖ Slot %d (%s): %s"), (int32)SlotType, *SlotNames[i], *EquippedItem->DisplayName.ToString()));
            }
        }
        else
        {
            if (GEngine)
            {
                GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Silver, 
                    FString::Printf(TEXT("‚ö™ Slot %d (%s): Empty"), (int32)SlotType, *SlotNames[i]));
            }
        }
    }
}

void UInventoryWidget::CreateEquipmentSlotWidget(const UEquippableItemData* Item, int32 SlotIndex, const FString& SlotName, EEquipmentSlotType SlotType)
{
    if (!EquipmentPanelRef) return;
    
    // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è —Å–ª–æ—Ç–∞
    UBorder* SlotContainer = WidgetTree->ConstructWidget<UBorder>(UBorder::StaticClass());
    SlotContainer->SetBrushColor(Item ? FLinearColor(0.3f, 0.7f, 0.3f, 0.8f) : FLinearColor(0.2f, 0.2f, 0.2f, 0.8f));
    
    // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º —Å–ª–æ—Ç–∞
    UTextBlock* SlotLabel = WidgetTree->ConstructWidget<UTextBlock>(UTextBlock::StaticClass());
    SlotLabel->SetText(FText::FromString(SlotName));
    SlotLabel->SetColorAndOpacity(FLinearColor::White);
    SlotLabel->SetJustification(ETextJustify::Center);
    SlotContainer->AddChild(SlotLabel);
    
    // –ï—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–µ–¥–º–µ—Ç –≤ —Å–ª–æ—Ç–µ, –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ –∏–∫–æ–Ω–∫—É –∏ —Å–æ–∑–¥–∞–µ–º –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –≤–∏–¥–∂–µ—Ç
    if (Item)
    {
        // –°–æ–∑–¥–∞–µ–º –≤–∏–¥–∂–µ—Ç –ø—Ä–µ–¥–º–µ—Ç–∞ –¥–ª—è —Å–ª–æ—Ç–∞ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏
        UInventoryItemWidget* ItemWidget = WidgetTree->ConstructWidget<UInventoryItemWidget>(UInventoryItemWidget::StaticClass());
        UTexture2D* Icon = Item->Icon ? Item->Icon : LoadObject<UTexture2D>(nullptr, TEXT("/Engine/EngineResources/WhiteSquareTexture.WhiteSquareTexture"));
        ItemWidget->Init(const_cast<UEquippableItemData*>(Item), Icon, EquipmentSlotSize);
        
        // –î–æ–±–∞–≤–ª—è–µ–º –≤–∏–¥–∂–µ—Ç –ø—Ä–µ–¥–º–µ—Ç–∞ –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
        SlotContainer->AddChild(ItemWidget);
        
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Green, 
                FString::Printf(TEXT("‚úÖ Created equipment slot widget for: %s"), *Item->DisplayName.ToString()));
        }
    }
    else
    {
        // –°–æ–∑–¥–∞–µ–º –ø—É—Å—Ç–æ–π —Å–ª–æ—Ç —Å —Ç–µ–∫—Å—Ç–æ–º "–ü—É—Å—Ç–æ"
        UTextBlock* EmptyLabel = WidgetTree->ConstructWidget<UTextBlock>(UTextBlock::StaticClass());
        EmptyLabel->SetText(FText::FromString(TEXT("–ü—É—Å—Ç–æ")));
        EmptyLabel->SetColorAndOpacity(FLinearColor(0.7f, 0.7f, 0.7f, 1.0f));
        EmptyLabel->SetJustification(ETextJustify::Center);
        SlotContainer->AddChild(EmptyLabel);
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º —Å–ª–æ—Ç –≤ –ø–∞–Ω–µ–ª—å
    if (UCanvasPanelSlot* CanvasSlot = EquipmentPanelRef->AddChildToCanvas(SlotContainer))
    {
        CanvasSlot->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
        CanvasSlot->SetAlignment(FVector2D(0.f, 0.f));
        // –†–∞–∑–º–µ—â–∞–µ–º —Å–ª–æ—Ç—ã —Å–ª–µ–≤–∞ –æ—Ç –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        CanvasSlot->SetPosition(FVector2D(20.f, 10.f + SlotIndex * (EquipmentSlotSize.Y + 10.f)));
        CanvasSlot->SetSize(EquipmentSlotSize);
        CanvasSlot->SetZOrder(10);
    }
    
    EquipmentSlotWidgets.Add(SlotContainer);
}

void UInventoryWidget::UpdateStaticEquipmentSlots()
{
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Cyan, TEXT("üîç UpdateStaticEquipmentSlots called"));
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ª–æ—Ç "—Ä–∞–∑–≥—Ä—É–∑–∫–∞"
    if (VestSlotRef)
    {
        // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏ –æ—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
        APlayerController* PC = GetOwningPlayer();
        if (PC)
        {
            APlayerCharacter* PlayerChar = Cast<APlayerCharacter>(PC->GetPawn());
            if (PlayerChar && PlayerChar->InventoryComponent)
            {
                UInventoryComponent* InvComp = PlayerChar->InventoryComponent;
                UEquippableItemData* EquippedVest = InvComp->GetEquippedItem(Vest);
                
                if (EquippedVest)
                {
                    // –ï—Å–ª–∏ –≤–∏–¥–∂–µ—Ç —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –æ–±–Ω–æ–≤–ª—è–µ–º –µ–≥–æ –¥–∞–Ω–Ω—ã–µ
                    if (VestItemWidgetRef && VestItemWidgetRef->IsValidLowLevel())
                    {
                        // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –≤–∏–¥–∂–µ—Ç–∞
                        UTexture2D* Icon = EquippedVest->Icon ? EquippedVest->Icon : LoadObject<UTexture2D>(nullptr, TEXT("/Engine/EngineResources/WhiteSquareTexture.WhiteSquareTexture"));
                        VestItemWidgetRef->Init(const_cast<UEquippableItemData*>(EquippedVest), Icon, FVector2D(80.f, 80.f));
                        
                        // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ —Ñ–ª–∞–≥ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–ª–æ—Ç–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
                        VestItemWidgetRef->SetStaticEquipmentSlot(true);
                        
                        if (GEngine)
                        {
                            GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Green, 
                                FString::Printf(TEXT("‚úÖ Vest slot updated existing widget: %s"), *EquippedVest->DisplayName.ToString()));
                        }
                    }
                    else
                    {
                        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –≤–∏–¥–∂–µ—Ç –ø—Ä–µ–¥–º–µ—Ç–∞ –¥–ª—è —Å–ª–æ—Ç–∞
                        VestItemWidgetRef = WidgetTree->ConstructWidget<UInventoryItemWidget>(UInventoryItemWidget::StaticClass());
                        UTexture2D* Icon = EquippedVest->Icon ? EquippedVest->Icon : LoadObject<UTexture2D>(nullptr, TEXT("/Engine/EngineResources/WhiteSquareTexture.WhiteSquareTexture"));
                        VestItemWidgetRef->Init(const_cast<UEquippableItemData*>(EquippedVest), Icon, FVector2D(80.f, 80.f));
                        
                        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–ª–æ—Ç–∞ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏
                        VestItemWidgetRef->SetStaticEquipmentSlot(true);
                        
                        // –î–æ–±–∞–≤–ª—è–µ–º –≤–∏–¥–∂–µ—Ç –≤ —Å–ª–æ—Ç —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ–º
                        VestSlotRef->AddChild(VestItemWidgetRef);
                        
                        if (GEngine)
                        {
                            GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Green, 
                                FString::Printf(TEXT("‚úÖ Vest slot created new widget: %s"), *EquippedVest->DisplayName.ToString()));
                        }
                    }
                }
                else
                {
                    // –£–¥–∞–ª—è–µ–º –≤–∏–¥–∂–µ—Ç, –µ—Å–ª–∏ –∂–∏–ª–µ—Ç –Ω–µ —ç–∫–∏–ø–∏—Ä–æ–≤–∞–Ω
                    if (VestItemWidgetRef && VestItemWidgetRef->IsValidLowLevel())
                    {
                        VestSlotRef->RemoveChild(VestItemWidgetRef);
                        VestItemWidgetRef = nullptr;
                        
                        if (GEngine)
                        {
                            GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Silver, TEXT("‚ö™ Vest slot cleared"));
                        }
                    }
                }
            }
        }
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ª–æ—Ç "—Ä—é–∫–∑–∞–∫"
    if (BackpackSlotRef)
    {
        // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏ –æ—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
        APlayerController* PC = GetOwningPlayer();
        if (PC)
        {
            APlayerCharacter* PlayerChar = Cast<APlayerCharacter>(PC->GetPawn());
            if (PlayerChar && PlayerChar->InventoryComponent)
            {
                UInventoryComponent* InvComp = PlayerChar->InventoryComponent;
                UEquippableItemData* EquippedBackpack = InvComp->GetEquippedItem(Backpack);
                
                if (EquippedBackpack)
                {
                    // –ï—Å–ª–∏ –≤–∏–¥–∂–µ—Ç —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –æ–±–Ω–æ–≤–ª—è–µ–º –µ–≥–æ –¥–∞–Ω–Ω—ã–µ
                    if (BackpackItemWidgetRef && BackpackItemWidgetRef->IsValidLowLevel())
                    {
                        // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –≤–∏–¥–∂–µ—Ç–∞
                        UTexture2D* Icon = EquippedBackpack->Icon ? EquippedBackpack->Icon : LoadObject<UTexture2D>(nullptr, TEXT("/Engine/EngineResources/WhiteSquareTexture.WhiteSquareTexture"));
                        BackpackItemWidgetRef->Init(const_cast<UEquippableItemData*>(EquippedBackpack), Icon, FVector2D(80.f, 80.f));
                        
                        // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ —Ñ–ª–∞–≥ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–ª–æ—Ç–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
                        BackpackItemWidgetRef->SetStaticEquipmentSlot(true);
                        
                        if (GEngine)
                        {
                            GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Green, 
                                FString::Printf(TEXT("‚úÖ Backpack slot updated existing widget: %s"), *EquippedBackpack->DisplayName.ToString()));
                        }
                    }
                    else
                    {
                        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –≤–∏–¥–∂–µ—Ç –ø—Ä–µ–¥–º–µ—Ç–∞ –¥–ª—è —Å–ª–æ—Ç–∞
                        BackpackItemWidgetRef = WidgetTree->ConstructWidget<UInventoryItemWidget>(UInventoryItemWidget::StaticClass());
                        UTexture2D* Icon = EquippedBackpack->Icon ? EquippedBackpack->Icon : LoadObject<UTexture2D>(nullptr, TEXT("/Engine/EngineResources/WhiteSquareTexture.WhiteSquareTexture"));
                        BackpackItemWidgetRef->Init(const_cast<UEquippableItemData*>(EquippedBackpack), Icon, FVector2D(80.f, 80.f));
                        
                        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–ª–æ—Ç–∞ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏
                        BackpackItemWidgetRef->SetStaticEquipmentSlot(true);
                        
                        // –î–æ–±–∞–≤–ª—è–µ–º –≤–∏–¥–∂–µ—Ç –≤ —Å–ª–æ—Ç —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ–º
                        BackpackSlotRef->AddChild(BackpackItemWidgetRef);
                        
                        if (GEngine)
                        {
                            GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Green, 
                                FString::Printf(TEXT("‚úÖ Backpack slot created new widget: %s"), *EquippedBackpack->DisplayName.ToString()));
                        }
                    }
                }
                else
                {
                    // –£–¥–∞–ª—è–µ–º –≤–∏–¥–∂–µ—Ç, –µ—Å–ª–∏ —Ä—é–∫–∑–∞–∫ –Ω–µ —ç–∫–∏–ø–∏—Ä–æ–≤–∞–Ω
                    if (BackpackItemWidgetRef && BackpackItemWidgetRef->IsValidLowLevel())
                    {
                        BackpackSlotRef->RemoveChild(BackpackItemWidgetRef);
                        BackpackItemWidgetRef = nullptr;
                        
                        if (GEngine)
                        {
                            GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Silver, TEXT("‚ö™ Backpack slot cleared"));
                        }
                    }
                }
            }
        }
    }
}



void UInventoryWidget::RemoveItemWidget(UInventoryItemWidget* Widget)
{
    if (!Widget) return;
    if (RightPanelRef)
    {
        RightPanelRef->RemoveChild(Widget);
    }
    for (int32 i=Placed.Num()-1;i>=0;--i)
    {
        if (Placed[i].Widget == Widget)
        {
            Placed.RemoveAt(i);
        }
    }
}

void UInventoryWidget::RemoveItemMapping(UInventoryItemData* ItemData)
{
    ItemToWidget.Remove(ItemData);
}

void UInventoryWidget::ClearItemPosition(UInventoryItemData* ItemData)
{
    if (!ItemData) return;
    
    // –£–¥–∞–ª—è–µ–º –∏–∑ —Å–∏—Å—Ç–µ–º—ã drag & drop
    for (int32 i = Placed.Num() - 1; i >= 0; --i)
    {
        if (Placed[i].Widget && Placed[i].Widget->ItemData == ItemData)
        {
            Placed.RemoveAt(i);
            
            if (GEngine)
            {
                GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Cyan, 
                    FString::Printf(TEXT("üßπ Cleared drag&drop position for %s"), *ItemData->DisplayName.ToString()));
            }
            break;
        }
    }
}

void UInventoryWidget::SyncBackpack(const TArray<UInventoryItemData*>& Items)
{
    // Legacy function - no longer needed since backpack grid is removed
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Yellow, TEXT("‚ö†Ô∏è SyncBackpack called - backpack grid removed"));
    }
}

void UInventoryWidget::MarkCellsAsOccupied(int32 X, int32 Y, int32 SizeX, int32 SizeY)
{
    const int32 MaxCols = OccupiedCells.Num() > 0 ? OccupiedCells[0].Num() : 0;
    const int32 MaxRows = OccupiedCells.Num();
    
    for (int32 dy = 0; dy < SizeY && Y + dy < MaxRows; ++dy)
    {
        for (int32 dx = 0; dx < SizeX && X + dx < MaxCols; ++dx)
        {
            if (Y + dy >= 0 && X + dx >= 0)
            {
                OccupiedCells[Y + dy][X + dx] = true;
            }
        }
    }
}

void UInventoryWidget::MarkCellsAsFree(int32 X, int32 Y, int32 SizeX, int32 SizeY)
{
    const int32 MaxCols = OccupiedCells.Num() > 0 ? OccupiedCells[0].Num() : 0;
    const int32 MaxRows = OccupiedCells.Num();
    
    for (int32 dy = 0; dy < SizeY && Y + dy < MaxRows; ++dy)
    {
        for (int32 dx = 0; dx < SizeX && X + dx < MaxCols; ++dx)
        {
            if (Y + dy >= 0 && X + dx >= 0)
            {
                OccupiedCells[Y + dy][X + dx] = false;
            }
        }
    }
}

bool UInventoryWidget::AreCellsFree(int32 X, int32 Y, int32 SizeX, int32 SizeY) const
{
    const int32 MaxCols = OccupiedCells.Num() > 0 ? OccupiedCells[0].Num() : 0;
    const int32 MaxRows = OccupiedCells.Num();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã
    if (X < 0 || Y < 0 || X + SizeX > MaxCols || Y + SizeY > MaxRows)
    {
        return false;
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–Ω—è—Ç–æ—Å—Ç—å —è—á–µ–µ–∫
    for (int32 dy = 0; dy < SizeY; ++dy)
    {
        for (int32 dx = 0; dx < SizeX; ++dx)
        {
            if (OccupiedCells[Y + dy][X + dx])
            {
                return false;
            }
        }
    }
    
    return true;
}

void UInventoryWidget::RegisterGrid(const FString& Name, const FVector2D& Pos, const FVector2D& Size, int32 CellsX, int32 CellsY)
{
    FGridArea Area;
    Area.Name = Name;
    Area.Position = Pos;
    Area.Size = Size;
    Area.CellsX = CellsX;
    Area.CellsY = CellsY;
    GridAreas.Add(Area);
}

int32 UInventoryWidget::FindGridAtPoint(const FVector2D& LocalPoint) const
{
    for (int32 i = 0; i < GridAreas.Num(); ++i)
    {
        const FGridArea& Area = GridAreas[i];
        if (LocalPoint.X >= Area.Position.X && LocalPoint.Y >= Area.Position.Y &&
            LocalPoint.X < Area.Position.X + Area.Size.X && LocalPoint.Y < Area.Position.Y + Area.Size.Y)
        {
            return i;
        }
    }
    return INDEX_NONE;
}

FVector2D UInventoryWidget::SnapToCellInGrid(int32 GridIndex, const FVector2D& LocalPoint) const
{
    if (!GridAreas.IsValidIndex(GridIndex)) return LocalPoint;
    
    const FGridArea& A = GridAreas[GridIndex];
    const FVector2D CellSize = FVector2D(A.Size.X / A.CellsX, A.Size.Y / A.CellsY);
    const int32 X = FMath::Clamp((int32)FMath::FloorToInt((LocalPoint.X - A.Position.X) / CellSize.X), 0, A.CellsX-1);
    const int32 Y = FMath::Clamp((int32)FMath::FloorToInt((LocalPoint.Y - A.Position.Y) / CellSize.Y), 0, A.CellsY-1);
    return A.Position + FVector2D(X * CellSize.X, Y * CellSize.Y);
}

bool UInventoryWidget::TryAutoPlaceInGrid(int32 GridIndex, int32 SizeX, int32 SizeY, int32& OutCellX, int32& OutCellY) const
{
    if (!GridAreas.IsValidIndex(GridIndex)) return false;
    
    const FGridArea& A = GridAreas[GridIndex];
    for (int32 Y = 0; Y <= A.CellsY - SizeY; ++Y)
    {
        for (int32 X = 0; X <= A.CellsX - SizeX; ++X)
        {
            if (IsAreaFree(GridIndex, X, Y, SizeX, SizeY, nullptr))
            {
                OutCellX = X;
                OutCellY = Y;
                return true;
            }
        }
    }
    return false;
}

bool UInventoryWidget::IsAreaFree(int32 GridIndex, int32 CellX, int32 CellY, int32 SizeX, int32 SizeY, UInventoryItemWidget* Ignore) const
{
    if (!GridAreas.IsValidIndex(GridIndex)) return false;
    const FGridArea& A = GridAreas[GridIndex];
    // –î–ª—è –≥—Ä–∏–¥–æ–≤ –∂–∏–ª–µ—Ç–∞ –ø–æ–∫–∞ –Ω–µ –≤–µ–¥—ë–º —É—á—ë—Ç –∑–∞–Ω—è—Ç–æ—Å—Ç–∏ ‚Äî —Ä–∞–∑—Ä–µ—à–∞–µ–º –¥—Ä–æ–ø –ø—Ä–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–∏ –≤ –≥—Ä–∞–Ω–∏—Ü—ã
    if (A.Name.StartsWith(TEXT("–∂–∏–ª–µ—Ç")))
    {
        return (CellX >= 0 && CellY >= 0 && CellX + SizeX <= A.CellsX && CellY + SizeY <= A.CellsY);
    }
    
    if (CellX < 0 || CellY < 0 || CellX + SizeX > A.CellsX || CellY + SizeY > A.CellsY) return false;
    for (const FPlacedItem& P : Placed)
    {
        if (P.Widget == Ignore) continue;
        if (P.GridIndex != GridIndex) continue;
        const int32 Ax0 = CellX, Ay0 = CellY, Ax1 = CellX + SizeX - 1, Ay1 = CellY + SizeY - 1;
        const int32 Bx0 = P.CellX, By0 = P.CellY, Bx1 = P.CellX + P.SizeX - 1, By1 = P.CellY + P.SizeY - 1;
        const bool bOverlap = !(Ax1 < Bx0 || Bx1 < Ax0 || Ay1 < By0 || By1 < Ay0);
        if (bOverlap) return false;
    }
    return true;
}

void UInventoryWidget::UpsertPlacement(UInventoryItemWidget* Widget, int32 GridIndex, int32 CellX, int32 CellY)
{
    if (!Widget) return;
    int32 SX = Widget->bRotated ? Widget->SizeY : Widget->SizeX;
    int32 SY = Widget->bRotated ? Widget->SizeX : Widget->SizeY;
    for (FPlacedItem& P : Placed)
    {
        if (P.Widget == Widget)
        {
            P.GridIndex = GridIndex; P.CellX = CellX; P.CellY = CellY; P.SizeX = SX; P.SizeY = SY; P.bRotated = Widget->bRotated;
            return;
        }
    }
    FPlacedItem NewP; NewP.Widget=Widget; NewP.GridIndex=GridIndex; NewP.CellX=CellX; NewP.CellY=CellY; NewP.SizeX=SX; NewP.SizeY=SY; NewP.bRotated=Widget->bRotated; Placed.Add(NewP);
}



void UInventoryWidget::CreateVestGrid()
{
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Cyan, TEXT("üîç CreateVestGrid called"));
    }
    
    if (VestGrids.Num() > 0)
    {
        DestroyVestGrid();
    }
    
    // –†–∞–∑–º–µ—â–∞–µ–º –≥—Ä–∏–¥—ã –∂–∏–ª–µ—Ç–∞ –≤–Ω—É—Ç—Ä–∏ RightPanelRef, —á—Ç–æ–±—ã –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å–æ–≤–ø–∞–¥–∞–ª–∏ —Å hit-test
    UCanvasPanel* RightPanel = RightPanelRef;
    if (!RightPanel)
    {
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Red, TEXT("‚ùå RightPanelRef not found"));
        }
        return;
    }
    
    // –°–æ–∑–¥–∞–µ–º –≥—Ä–∏–¥ –∂–∏–ª–µ—Ç–∞ –≤ —Å—Ç–∏–ª–µ –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –≥—Ä–∏–¥–æ–≤
    auto AddVestLabeledGrid = [&](const TCHAR* Label, float XPos, float YPos, FVector2D GridSize, int32 GridWidth, int32 GridHeight, const TCHAR* SlotLabel = nullptr, bool bShowLabel = true)
    {
        // –°–ª–æ—Ç —Å–ª–µ–≤–∞ –æ—Ç –Ω–∞–¥–ø–∏—Å–∏
        if (SlotLabel)
        {
            UBorder* Slot = WidgetTree->ConstructWidget<UBorder>(UBorder::StaticClass());
            Slot->SetBrushColor(FLinearColor(1.f,1.f,1.f,0.05f));
            if (UCanvasPanelSlot* SS = RightPanel->AddChildToCanvas(Slot))
            {
                SS->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                SS->SetAlignment(FVector2D(0.f, 0.f));
                SS->SetPosition(FVector2D(XPos, YPos));
                SS->SetSize(FVector2D(60.f, 60.f));
            }
            
            UTextBlock* SlotText = WidgetTree->ConstructWidget<UTextBlock>(UTextBlock::StaticClass());
            SlotText->SetText(FText::FromString(SlotLabel));
            SlotText->SetColorAndOpacity(FSlateColor(FLinearColor::White));
            SlotText->SetJustification(ETextJustify::Center);
            if (UCanvasPanelSlot* ST = RightPanel->AddChildToCanvas(SlotText))
            {
                ST->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                ST->SetAlignment(FVector2D(0.f, 0.f));
                ST->SetPosition(FVector2D(XPos, YPos));
                ST->SetSize(FVector2D(60.f, 60.f));
            }
        }
        
        // –°–æ–∑–¥–∞–µ–º –≥—Ä–∏–¥
        const FName GridName(*FString::Printf(TEXT("VestGrid_%s"), Label));
        UCanvasPanel* Grid = WidgetTree->ConstructWidget<UCanvasPanel>(UCanvasPanel::StaticClass(), GridName);
        if (Grid)
        {
            VestGrids.Add(Grid); // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –≤ –º–∞—Å—Å–∏–≤
            VestGridSizes.Add(GridSize); // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–∞–∑–º–µ—Ä
            
            FVector2D Pos = FVector2D(XPos, YPos);
            if (UCanvasPanelSlot* GS = RightPanel->AddChildToCanvas(Grid))
            {
                GS->SetAnchors(FAnchors(0.f, 0.f, 0.f, 0.f));
                GS->SetAlignment(FVector2D(0.f, 0.f));
                GS->SetPosition(Pos);
                GS->SetSize(GridSize);
                GS->SetAutoSize(false);
                GS->SetZOrder(5); // —Ä–µ–Ω–¥–µ—Ä–∏–º –ø–æ–≤–µ—Ä—Ö
                RegisterGrid(Label, Pos, GridSize, GridWidth, GridHeight);
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Ñ–æ–Ω –≥—Ä–∏–¥–∞ (–≤–∏–¥–∏–º—ã–π)
            UBorder* GridBackground = WidgetTree->ConstructWidget<UBorder>(UBorder::StaticClass());
            if (GridBackground)
            {
                GridBackground->SetBrushColor(FLinearColor(0.2f, 0.8f, 0.2f, 0.3f)); // –ó–µ–ª–µ–Ω—ã–π —Ñ–æ–Ω –¥–ª—è –≤–∏–¥–∏–º–æ—Å—Ç–∏
                UCanvasPanelSlot* BgSlot = Grid->AddChildToCanvas(GridBackground);
                if (BgSlot)
                {
                    BgSlot->SetAnchors(FAnchors(0.0f, 0.0f, 1.0f, 1.0f));
                    BgSlot->SetOffsets(FMargin(0.0f));
                }
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Å–µ—Ç–∫—É —è—á–µ–µ–∫
            const int32 CellSize = 60;
            for (int32 Row = 0; Row < GridHeight; ++Row)
            {
                for (int32 Col = 0; Col < GridWidth; ++Col)
                {
                    // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è —è—á–µ–π–∫–∏
                    const FName CellName(*FString::Printf(TEXT("VestCell_%s_r%d_c%d"), Label, Row, Col));
                    UCanvasPanel* CellContainer = WidgetTree->ConstructWidget<UCanvasPanel>(UCanvasPanel::StaticClass(), CellName);
                    if (CellContainer)
                    {
                        // –î–æ–±–∞–≤–ª—è–µ–º —Ñ–æ–Ω —è—á–µ–π–∫–∏
                        const FName CellBgName(*FString::Printf(TEXT("VestCellBg_%s_r%d_c%d"), Label, Row, Col));
                        UBorder* CellBackground = WidgetTree->ConstructWidget<UBorder>(UBorder::StaticClass(), CellBgName);
                        if (CellBackground)
                        {
                            CellBackground->SetBrushColor(FLinearColor(0.0f, 0.0f, 1.0f, 0.2f)); // –°–∏–Ω–∏–π —Ñ–æ–Ω
                            UCanvasPanelSlot* BgSlot = CellContainer->AddChildToCanvas(CellBackground);
                            if (BgSlot)
                            {
                                BgSlot->SetAnchors(FAnchors(0.0f, 0.0f, 1.0f, 1.0f));
                                BgSlot->SetOffsets(FMargin(1.0f)); // –û—Ç—Å—Ç—É–ø—ã –¥–ª—è –≥—Ä–∞–Ω–∏—Ü
                            }
                        }
                        
                        // –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –≤ –≥—Ä–∏–¥
                        UCanvasPanelSlot* CellSlot = Grid->AddChildToCanvas(CellContainer);
                        if (CellSlot)
                        {
                            CellSlot->SetPosition(FVector2D(Col * CellSize, Row * CellSize));
                            CellSlot->SetSize(FVector2D(CellSize, CellSize));
                        }
                    }
                }
            }
            
            if (GEngine)
            {
                GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Green, 
                    FString::Printf(TEXT("‚úÖ Vest grid created: %s Pos(%.0f,%.0f), Size(%.0fx%.0f)"), 
                        *GridName.ToString(), Pos.X, Pos.Y, GridSize.X, GridSize.Y));
            }
        }
    };
    
    // –°–æ–∑–¥–∞–µ–º 6 –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –≥—Ä–∏–¥–æ–≤ –∂–∏–ª–µ—Ç–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ –≤ –æ–¥–Ω—É –ª–∏–Ω–∏—é
    // –í—Å–µ –≥—Ä–∏–¥—ã –Ω–∞ –æ–¥–Ω–æ–π –≤—ã—Å–æ—Ç–µ Y=200.f, –Ω–æ —Å —Ä–∞–∑–Ω—ã–º–∏ X –ø–æ–∑–∏—Ü–∏—è–º–∏
    // –†–∞—Å–ø–æ–ª–∞–≥–∞–µ–º —Å—Ä–∞–∑—É –Ω–∞–¥ –ø–æ—è—Å–æ–º (TopOffset –ø–æ—è—Å–∞: 280, –≤—ã—Å–æ—Ç–∞ –∂–∏–ª–µ—Ç–∞ –¥–æ 120) -> –≤—ã–±–µ—Ä–µ–º 220
    const float VestY = 220.f;
    // –†–∞–∑–º–µ—â–∞–µ–º –≤–Ω—É—Ç—Ä–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç RightPanel (0..RightPanel.Width). –ù–∞—á–Ω—ë–º –æ—Ç 70 –∫–∞–∫ —É –¥—Ä—É–≥–∏—Ö –≥—Ä–∏–¥–æ–≤
    const float VestXStart = 70.f;
    const float Step = 70.f;        // —à–∞–≥ –º–µ–∂–¥—É —Å–µ–∫—Ü–∏—è–º–∏ (60 + 10)
    AddVestLabeledGrid(TEXT("–∂–∏–ª–µ—Ç1"), VestXStart + Step * 0, VestY, FVector2D(60.f, 60.f), 1, 1, nullptr, false);
    AddVestLabeledGrid(TEXT("–∂–∏–ª–µ—Ç2"), VestXStart + Step * 1, VestY, FVector2D(60.f, 60.f), 1, 1, nullptr, false);
    AddVestLabeledGrid(TEXT("–∂–∏–ª–µ—Ç3"), VestXStart + Step * 2, VestY, FVector2D(60.f, 120.f), 1, 2, nullptr, false);
    AddVestLabeledGrid(TEXT("–∂–∏–ª–µ—Ç4"), VestXStart + Step * 3, VestY, FVector2D(60.f, 120.f), 1, 2, nullptr, false);
    AddVestLabeledGrid(TEXT("–∂–∏–ª–µ—Ç5"), VestXStart + Step * 4, VestY, FVector2D(60.f, 60.f), 1, 1, nullptr, false);
    AddVestLabeledGrid(TEXT("–∂–∏–ª–µ—Ç6"), VestXStart + Step * 5, VestY, FVector2D(60.f, 60.f), 1, 1, nullptr, false);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≥—Ä–∏–¥—ã —Å–æ–∑–¥–∞–ª–∏—Å—å
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Cyan, 
            FString::Printf(TEXT("üîç Created %d vest grids successfully"), VestGrids.Num()));
    }
}


void UInventoryWidget::DestroyVestGrid()
{
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Cyan, 
            FString::Printf(TEXT("üîç DestroyVestGrid called, destroying %d grids"), VestGrids.Num()));
    }
    
    // –£–¥–∞–ª—è–µ–º –≤—Å–µ –≥—Ä–∏–¥—ã –∂–∏–ª–µ—Ç–∞
    for (int32 GridIdx = 0; GridIdx < VestGrids.Num(); ++GridIdx)
    {
        UCanvasPanel* Grid = VestGrids[GridIdx];
        if (Grid)
        {
            if (GEngine)
            {
                GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Yellow,
                    FString::Printf(TEXT("üóëÔ∏è Removing VestGrid[%d]: %s, children: %d"), GridIdx, *Grid->GetName(), Grid->GetChildrenCount()));
            }

            // –°–Ω–∞—á–∞–ª–∞ –æ—á–∏—â–∞–µ–º –≤—Å–µ—Ö –¥–µ—Ç–µ–π –≥—Ä–∏–¥–∞
            Grid->ClearChildren();
            // –û—á–∏—â–∞–µ–º –≤—Å–µ –≤–∏–¥–∂–µ—Ç—ã –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –∏–∑ —ç—Ç–æ–≥–æ –≥—Ä–∏–¥–∞
            for (auto& Pair : ItemToWidget)
            {
                if (Pair.Value && Pair.Value->bIsStaticEquipmentSlot == false)
                {
                    UCanvasPanel* ParentPanel = Cast<UCanvasPanel>(Pair.Value->GetParent());
                    if (ParentPanel == Grid)
                    {
                        Pair.Value->RemoveFromParent();
                    }
                }
            }
            
            // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —É–¥–∞–ª—è–µ–º –≥—Ä–∏–¥
            Grid->RemoveFromParent();
        }
    }
    
    VestGrids.Empty();
    VestGridSizes.Empty();
    
    // –û—á–∏—â–∞–µ–º –∑–∞–Ω—è—Ç—ã–µ —è—á–µ–π–∫–∏ –≥—Ä–∏–¥–æ–≤ –∂–∏–ª–µ—Ç–∞
    VestOccupiedCells.Empty();
    
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ: –ø—Ä–æ—Ö–æ–¥–∏–º –ø–æ RightPanelRef –∏ —É–¥–∞–ª—è–µ–º –ª—é–±—ã–µ –æ—Å—Ç–∞–≤—à–∏–µ—Å—è VestGrid*
    if (RightPanelRef)
    {
        TArray<UWidget*> ToRemove;
        const int32 Count = RightPanelRef->GetChildrenCount();
        for (int32 i = 0; i < Count; ++i)
        {
            if (UWidget* Child = RightPanelRef->GetChildAt(i))
            {
                if (Child->GetName().StartsWith(TEXT("VestGrid_")))
                {
                    ToRemove.Add(Child);
                }
            }
        }
        for (UWidget* W : ToRemove)
        {
            if (GEngine)
            {
                GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red,
                    FString::Printf(TEXT("üßπ Sweeping leftover widget: %s"), *W->GetName()));
            }
            RightPanelRef->RemoveChild(W);
        }
    }
    
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Yellow, 
            FString::Printf(TEXT("üóëÔ∏è –£–Ω–∏—á—Ç–æ–∂–µ–Ω—ã –≤—Å–µ –≥—Ä–∏–¥—ã –∂–∏–ª–µ—Ç–∞ (–±—ã–ª–æ: %d)"), VestGrids.Num()));
    }
}


void UInventoryWidget::UpdateVestGrid()
{
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Cyan, 
            FString::Printf(TEXT("üîç UpdateVestGrid called, current grids: %d"), VestGrids.Num()));
    }
    
    // –ù–µ –≤—ã—Ö–æ–¥–∏–º, –µ—Å–ª–∏ VestGridRef == nullptr ‚Äî –Ω–∏–∂–µ —Å–æ–∑–¥–∞–¥–∏–º –≥—Ä–∏–¥ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
    
    // –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –∏ —ç–∫–∏–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∂–∏–ª–µ—Ç
    APlayerCharacter* PlayerChar = Cast<APlayerCharacter>(GetOwningPlayerPawn());
    if (!PlayerChar || !PlayerChar->InventoryComponent) 
    {
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Red, TEXT("‚ùå PlayerChar or InventoryComponent is null"));
        }
        return;
    }
    
    UEquippableItemData* EquippedVest = Cast<UEquippableItemData>(PlayerChar->InventoryComponent->GetEquippedItem(Vest));
    
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Yellow, 
            FString::Printf(TEXT("üîç EquippedVest: %s, HasStorage: %s, CurrentGrids: %d"), 
                EquippedVest ? TEXT("Found") : TEXT("Null"),
                EquippedVest && EquippedVest->bHasAdditionalStorage ? TEXT("Yes") : TEXT("No"),
                VestGrids.Num()));
    }
    
    // –£–ø—Ä–∞–≤–ª—è–µ–º –≥—Ä–∏–¥–æ–º –∂–∏–ª–µ—Ç–∞
    if (EquippedVest && EquippedVest->bHasAdditionalStorage)
    {
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Green, TEXT("‚úÖ –ñ–∏–ª–µ—Ç –Ω–∞–π–¥–µ–Ω —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º —Ö—Ä–∞–Ω–∏–ª–∏—â–µ–º"));
        }
        // –°–æ–∑–¥–∞—ë–º –≥—Ä–∏–¥—ã —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏—Ö –µ—â—ë –Ω–µ—Ç. –ù–µ –ø–µ—Ä–µ—Å–æ–∑–¥–∞—ë–º, —á—Ç–æ–±—ã –Ω–µ —É–¥–∞–ª—è—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
        if (VestGrids.Num() == 0)
        {
            if (GEngine)
            {
                GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Yellow, TEXT("üîß –°–æ–∑–¥–∞—ë–º –≥—Ä–∏–¥—ã –∂–∏–ª–µ—Ç–∞ (–æ–¥–Ω–æ–∫—Ä–∞—Ç–Ω–æ)"));
            }
            CreateVestGrid();
        }
    }
    else
    {
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Red, TEXT("‚ùå –ñ–∏–ª–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –±–µ–∑ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞"));
        }
        
        if (VestGrids.Num() > 0)
        {
            if (GEngine)
            {
                GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Yellow, TEXT("üóëÔ∏è –£–¥–∞–ª—è–µ–º –≥—Ä–∏–¥—ã –∂–∏–ª–µ—Ç–∞..."));
            }
            DestroyVestGrid();
        }
        return; // –ï—Å–ª–∏ –∂–∏–ª–µ—Ç –Ω–µ —ç–∫–∏–ø–∏—Ä–æ–≤–∞–Ω, –≤—ã—Ö–æ–¥–∏–º
    }
    
    // –ü–æ–ª—É—á–∞–µ–º –ø—Ä–µ–¥–º–µ—Ç—ã –∏–∑ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ –∂–∏–ª–µ—Ç–∞
    TArray<UInventoryItemData*> VestItems = PlayerChar->InventoryComponent->GetEquipmentStorageItems(EquippedVest);
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–∞—Å—Å–∏–≤ VestOccupiedCells –µ—Å–ª–∏ –æ–Ω –ø—É—Å—Ç–æ–π
    if (VestOccupiedCells.Num() == 0)
    {
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Yellow, TEXT("üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º VestOccupiedCells..."));
        }
        
        VestOccupiedCells.SetNum(6); // 6 –≥—Ä–∏–¥–æ–≤
        // –ì—Ä–∏–¥—ã 1-2: 1x1
        for (int32 GridIndex = 0; GridIndex < 2; ++GridIndex)
        {
            VestOccupiedCells[GridIndex].SetNum(1); // 1 —Ä—è–¥
            VestOccupiedCells[GridIndex][0].SetNum(1); // 1 –∫–æ–ª–æ–Ω–∫–∞
            VestOccupiedCells[GridIndex][0][0] = false;
        }
        // –ì—Ä–∏–¥—ã 3-4: 1x2
        for (int32 GridIndex = 2; GridIndex < 4; ++GridIndex)
        {
            VestOccupiedCells[GridIndex].SetNum(2); // 2 —Ä—è–¥–∞
            for (int32 Row = 0; Row < 2; ++Row)
            {
                VestOccupiedCells[GridIndex][Row].SetNum(1); // 1 –∫–æ–ª–æ–Ω–∫–∞
                VestOccupiedCells[GridIndex][Row][0] = false;
            }
        }
        // –ì—Ä–∏–¥—ã 5-6: 1x1
        for (int32 GridIndex = 4; GridIndex < 6; ++GridIndex)
        {
            VestOccupiedCells[GridIndex].SetNum(1); // 1 —Ä—è–¥
            VestOccupiedCells[GridIndex][0].SetNum(1); // 1 –∫–æ–ª–æ–Ω–∫–∞
            VestOccupiedCells[GridIndex][0][0] = false;
        }
    }
    
    // –û—á–∏—â–∞–µ–º –∑–∞–Ω—è—Ç—ã–µ —è—á–µ–π–∫–∏ –¥–ª—è –≤—Å–µ—Ö 6 –≥—Ä–∏–¥–æ–≤ (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è)
    for (int32 GridIndex = 0; GridIndex < 6; ++GridIndex)
    {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º–∞—Å—Å–∏–≤ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
        if (GridIndex < VestOccupiedCells.Num() && VestOccupiedCells[GridIndex].Num() > 0)
        {
            if (GridIndex < 2 || GridIndex >= 4) // –ì—Ä–∏–¥—ã 1-2 –∏ 5-6: 1x1
            {
                if (VestOccupiedCells[GridIndex][0].Num() > 0)
                {
                    VestOccupiedCells[GridIndex][0][0] = false;
                }
            }
            else // –ì—Ä–∏–¥—ã 3-4: 1x2
            {
                if (VestOccupiedCells[GridIndex][0].Num() > 0)
                {
                    VestOccupiedCells[GridIndex][0][0] = false;
                }
                if (VestOccupiedCells[GridIndex].Num() > 1 && VestOccupiedCells[GridIndex][1].Num() > 0)
                {
                    VestOccupiedCells[GridIndex][1][0] = false;
                }
            }
        }
    }
    
    // –†–∞–∑–º–µ—â–∞–µ–º –ø—Ä–µ–¥–º–µ—Ç—ã –≤ –≥—Ä–∏–¥–∞—Ö (–ø–æ–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–æ –¥–ª—è 6 –≥—Ä–∏–¥–æ–≤)
    // for (int32 i = 0; i < VestItems.Num(); ++i)
    // {
    //     AddVestGridItemIcon(VestItems[i], i);
    // }
}


void UInventoryWidget::ForceClearVestGrids()
{
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Red, 
            FString::Printf(TEXT("üóëÔ∏è ForceClearVestGrids called, destroying %d grids"), VestGrids.Num()));
    }
    
    // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —É–¥–∞–ª—è–µ–º –≤—Å–µ –≥—Ä–∏–¥—ã –∂–∏–ª–µ—Ç–∞
    DestroyVestGrid();
    
    // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º UI –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è –≥—Ä–∏–¥–æ–≤
    if (RightPanelRef)
    {
        RightPanelRef->InvalidateLayoutAndVolatility();
    }
    
    // –¢–∞–∫–∂–µ –æ–±–Ω–æ–≤–ª—è–µ–º –≤–µ—Å—å –≤–∏–¥–∂–µ—Ç
    InvalidateLayoutAndVolatility();
    
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Green, TEXT("‚úÖ All vest grids force cleared and UI updated"));
    }
}

void UInventoryWidget::AddVestGridItemIcon(UInventoryItemData* ItemData, int32 Index)
{
    if (!ItemData || VestGrids.Num() == 0) return;
    
    // –°–æ–∑–¥–∞–µ–º –≤–∏–¥–∂–µ—Ç –ø—Ä–µ–¥–º–µ—Ç–∞
    UInventoryItemWidget* ItemWidget = WidgetTree->ConstructWidget<UInventoryItemWidget>(UInventoryItemWidget::StaticClass());
    if (!ItemWidget) return;
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≤–∏–¥–∂–µ—Ç
    ItemWidget->Init(ItemData, ItemData->Icon, FVector2D(60.f, 60.f));
    
    // –†–∞–∑–º–µ—â–∞–µ–º –≤ –≥—Ä–∏–¥–µ –∂–∏–ª–µ—Ç–∞ (–ø—Ä–æ—Å—Ç–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –ø–æ –ø–æ—Ä—è–¥–∫—É)
    const int32 CellSize = 60;
    int32 CellX = Index % 6; // 6 –∫–æ–ª–æ–Ω–æ–∫
    int32 CellY = Index / 6; // 2 —Ä—è–¥–∞
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –Ω–µ –≤—ã—Ö–æ–¥–∏–º –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã
    if (CellY >= 2) return;
    
    // UCanvasPanelSlot* ItemSlot = VestGridRef->AddChildToCanvas(ItemWidget);
    // if (ItemSlot)
    // {
    //     FVector2D ItemSize = FVector2D(ItemData->SizeInCellsX * CellSize, ItemData->SizeInCellsY * CellSize);
    //     ItemSlot->SetPosition(FVector2D(CellX * CellSize, CellY * CellSize));
    //     ItemSlot->SetSize(ItemSize);
    // }
    
    // –û—Ç–º–µ—á–∞–µ–º —è—á–µ–π–∫–∏ –∫–∞–∫ –∑–∞–Ω—è—Ç—ã–µ
    for (int32 dy = 0; dy < ItemData->SizeInCellsY; ++dy)
    {
        for (int32 dx = 0; dx < ItemData->SizeInCellsX; ++dx)
        {
            if (CellY + dy < 2 && CellX + dx < 6)
            {
                // VestOccupiedCells[CellY + dy][CellX + dx] = true;
            }
        }
    }
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–≤—è–∑—å
    ItemToWidget.Add(ItemData, ItemWidget);
}

bool UInventoryWidget::CanDropOnVestGrid(const FGeometry& Geometry, const FVector2D& ScreenPosition) const
{
    // –§—É–Ω–∫—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å 6 –æ—Ç–¥–µ–ª—å–Ω—ã–º–∏ –≥—Ä–∏–¥–∞–º–∏
    return false;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –∫—É—Ä—Å–æ—Ä –Ω–∞–¥ –≥—Ä–∏–¥–æ–º –∂–∏–ª–µ—Ç–∞
    FVector2D LocalPosition = Geometry.AbsoluteToLocal(ScreenPosition);
    
    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∏ —Ä–∞–∑–º–µ—Ä –≥—Ä–∏–¥–∞ –∂–∏–ª–µ—Ç–∞
    FVector2D VestGridPosition = FVector2D(70.f, 300.f);
    FVector2D VestGridSizeLocal = FVector2D(360.f, 120.f);
    
    return LocalPosition.X >= VestGridPosition.X && 
           LocalPosition.X <= VestGridPosition.X + VestGridSizeLocal.X &&
           LocalPosition.Y >= VestGridPosition.Y && 
           LocalPosition.Y <= VestGridPosition.Y + VestGridSizeLocal.Y;
}

bool UInventoryWidget::HandleVestGridDrop(UInventoryItemData* ItemData, const FVector2D& Position)
{
    // –§—É–Ω–∫—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å 6 –æ—Ç–¥–µ–ª—å–Ω—ã–º–∏ –≥—Ä–∏–¥–∞–º–∏
    return false;
    
    // –ü–æ–ª—É—á–∞–µ–º —ç–∫–∏–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∂–∏–ª–µ—Ç
    APlayerCharacter* PlayerChar = Cast<APlayerCharacter>(GetOwningPlayerPawn());
    if (!PlayerChar || !PlayerChar->InventoryComponent) return false;
    
    UEquippableItemData* EquippedVest = Cast<UEquippableItemData>(PlayerChar->InventoryComponent->GetEquippedItem(Vest));
    if (!EquippedVest || !EquippedVest->bHasAdditionalStorage) return false;
    
    // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –≤ —è—á–µ–π–∫–∞—Ö –≥—Ä–∏–¥–∞
    FVector2D VestGridPosition = FVector2D(70.f, 300.f);
    FVector2D LocalPosition = Position - VestGridPosition;
    const int32 CellSize = 60;
    
    int32 CellX = FMath::FloorToInt(LocalPosition.X / CellSize);
    int32 CellY = FMath::FloorToInt(LocalPosition.Y / CellSize);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã
    if (CellX < 0 || CellX >= 6 || CellY < 0 || CellY >= 2) return false;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–º–µ—â–∞–µ—Ç—Å—è –ª–∏ –ø—Ä–µ–¥–º–µ—Ç
    if (CellX + ItemData->SizeInCellsX > 6 || CellY + ItemData->SizeInCellsY > 2) return false;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–≤–æ–±–æ–¥–Ω—ã –ª–∏ —è—á–µ–π–∫–∏
    for (int32 dy = 0; dy < ItemData->SizeInCellsY; ++dy)
    {
        for (int32 dx = 0; dx < ItemData->SizeInCellsX; ++dx)
        {
            if (CellY + dy >= 2 || CellX + dx >= 6) return false;
            // if (VestOccupiedCells[CellY + dy][CellX + dx]) return false;
        }
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–µ–¥–º–µ—Ç –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –∂–∏–ª–µ—Ç–∞
    bool bSuccess = PlayerChar->InventoryComponent->AddToEquipmentStorage(EquippedVest, ItemData);
    
    if (bSuccess)
    {
        // –û—Ç–º–µ—á–∞–µ–º —è—á–µ–π–∫–∏ –∫–∞–∫ –∑–∞–Ω—è—Ç—ã–µ
        for (int32 dy = 0; dy < ItemData->SizeInCellsY; ++dy)
        {
            for (int32 dx = 0; dx < ItemData->SizeInCellsX; ++dx)
            {
                // VestOccupiedCells[CellY + dy][CellX + dx] = true;
            }
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –≥—Ä–∏–¥
        UpdateVestGrid();
        
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Green, 
                FString::Printf(TEXT("‚úÖ Added '%s' to vest grid at (%d,%d)"), 
                    *ItemData->DisplayName.ToString(), CellX, CellY));
        }
    }
    
    return bSuccess;
}

bool UInventoryWidget::HandleVestGridItemDrag(UInventoryItemData* ItemData)
{
    if (!ItemData) return false;
    
    // –ü–æ–ª—É—á–∞–µ–º —ç–∫–∏–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∂–∏–ª–µ—Ç
    APlayerCharacter* PlayerChar = Cast<APlayerCharacter>(GetOwningPlayerPawn());
    if (!PlayerChar || !PlayerChar->InventoryComponent) return false;
    
    UEquippableItemData* EquippedVest = Cast<UEquippableItemData>(PlayerChar->InventoryComponent->GetEquippedItem(Vest));
    if (!EquippedVest || !EquippedVest->bHasAdditionalStorage) return false;
    
    // –£–¥–∞–ª—è–µ–º –ø—Ä–µ–¥–º–µ—Ç –∏–∑ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ –∂–∏–ª–µ—Ç–∞
    bool bSuccess = PlayerChar->InventoryComponent->RemoveFromEquipmentStorage(EquippedVest, ItemData);
    
    if (bSuccess)
    {
        // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–µ–¥–º–µ—Ç –æ–±—Ä–∞—Ç–Ω–æ –≤ —Ä—é–∫–∑–∞–∫
        PlayerChar->InventoryComponent->AddToBackpack(ItemData);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º UI
        SyncBackpack(PlayerChar->InventoryComponent->BackpackItems);
        
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Yellow, 
                FString::Printf(TEXT("üîÑ Moved '%s' from vest to backpack"), 
                    *ItemData->DisplayName.ToString()));
        }
    }
    
    return bSuccess;
}

FVector2D UInventoryWidget::GetVestGridCellPosition(int32 CellX, int32 CellY) const
{
    FVector2D VestGridPosition = FVector2D(70.f, 200.f); // –ù–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–∞–¥ –ø–æ—è—Å–æ–º
    const int32 CellSize = 60;
    
    return VestGridPosition + FVector2D(CellX * CellSize, CellY * CellSize);
}

// –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ä—é–∫–∑–∞–∫–æ–º

